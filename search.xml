<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Dynamic Programming]]></title>
    <url>%2F2018%2F05%2F10%2FDynamic-Programming%2F</url>
    <content type="text"><![CDATA[In computer science, mathematics, management science, economics and bioinformatics, dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions.1 Big Businessinput: 2 arrays a and b, where a represents the royalties of the film and b represents the money that the movie can sell. Principal k.output: return maximum profit can be made by principal (k). 典型的 DP, 求最大利润. 主要方向有2点, 如果售价比版权费要高, 才有利润, 否则怎么卖都是赔钱的. 通过买卖, 本金可能会增长, 从而可以购买更贵的电影. 数组 a 与 b 的关系是一一对应的, 那么肯定就不能对数组进行排序了. 第一个想法是, 通过不断循环的方式排查所有盈利的影片. 因为需要判断当前本金额度是否可以购买影片, 所以要保留版权费与利润之间一一对应的关系. 可以使用一个 Map&lt;a[i], b[i] - a[i&gt;], 同时在 map 不为空, 且利润不为零的情况下,不停的进行循环查找. 在完全倒序的的情况下, 时间复杂度会变成 O(n^2). 如果可以对版权费用进行排序, 那么就可以通过一次循环找出所有可能购买的影片. 时间复杂度是 O(nlogn + O(n)), 所以还是 O(nlogn). 12345678910111213141516171819202122232425public class BigBusiness &#123; /** * @param a: The cost of the film * @param b: The price of the selling of the film * @param k: The principal * @return: The answer */ public int bigBusiness(int[] a, int[] b, int k) &#123; if (a == null || b == null) &#123; return -1; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; a.length; i++)&#123; list.add(b[i] - a[i]); &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (list.get(i) &gt; 0 &amp;&amp; a[i] &lt;= k) &#123; k += list.get(i); &#125; &#125; return k; &#125;&#125; 1.Wiki ↩]]></content>
      <tags>
        <tag>Algorithm</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure VII Heap&PriorityQueue]]></title>
    <url>%2F2018%2F05%2F08%2FData-Structure-VII-Heap-PriorityQueue%2F</url>
    <content type="text"><![CDATA[Heap is a tree-like data structure. Every node must satisfy the heap property (max/min/etc). In java, heap is implemented as PriorityQueue&lt;&gt;(size, Comparator). Due to this property, the time complexity of insertion and deletion are both O(logn). Implement a Heap Using ArrayConstructor takes different parameters, with default capacity and heapify input array. Implements basic operations, offer, poll, peek, size, and isEmpty. With resize function, the priority queue can expand its capacity when it’s half full. The amortized time complexity for offer and poll remain constant.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134public class MyPQ &#123; private int size; private int SCALE = 2; private int INITIAL_CAP = 15; private int[] array; public MyPQ()&#123; array = new int[INITIAL_CAP]; size = 0; &#125; public MyPQ(int[] array) &#123; this.array = array; size = array.length; heapify(); &#125; public void offer(int e) &#123; if (size == array.length / 2) &#123; resize(); &#125; if (size == 0) &#123; array[0] = e; &#125; else &#123; array[size] = e; &#125; size++; percolateUp(); &#125; public Integer poll()&#123; if (size == 0) &#123; return null; &#125; int peek = array[0]; array[0] = array[size - 1]; size--; percolateDown(0); return peek; &#125; public Integer peek() &#123; if (size == 0) &#123; return null; &#125; return array[0]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; private void percolateUp() &#123; int index = size - 1; while (index &gt;= 0) &#123; int parent = (index - 1) / 2; if (array[index] &lt; array[parent]) &#123; swap(array, index, parent); &#125; else &#123; break; &#125; index = parent; &#125; &#125; private void percolateDown(int index) &#123; while (index &lt;= (size - 2) / 2) &#123; int left = index * 2 + 1; int right = index * 2 + 2; int smallest = left; if (array[right] &lt; array[left]) &#123; smallest = right; &#125; if (array[index] &lt; array[smallest]) &#123; break; &#125; else &#123; swap(array, smallest, index); &#125; index = smallest; &#125; &#125; private void heapify() &#123; for (int i = size / 2 - 1; i &gt;= 0; i--) &#123; percolateDown(i); &#125; &#125; private void resize() &#123; int[] newArr = new int[array.length * SCALE]; for (int i = 0; i &lt; array.length; i++) &#123; newArr[i] = array[i]; &#125; array = newArr; &#125; private void swap(int[] arr, int one, int two) &#123; int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp; &#125;&#125;public class MyPQTest &#123; private MyPQ pq = new MyPQ(); private MyPQ pq2 = new MyPQ(new int[]&#123;3, 5, 7, 0, 1, 2, -10&#125;); @Test public void offer() &#123; pq.offer(5); pq.offer(-1); pq.offer(0); pq.offer(9); assertEquals(-1, (Object)pq.peek()); assertEquals(-1, (Object)pq.poll()); assertEquals(3, pq.size()); assertEquals(false, pq.isEmpty()); assertEquals(0, (Object)pq.peek()); assertEquals(0, (Object)pq.poll()); assertEquals(2, pq.size()); assertEquals(5, (Object)pq.poll()); assertEquals(1, pq.size()); assertEquals(9, (Object)pq.poll()); assertEquals(null, pq.poll()); assertEquals(true, pq.isEmpty()); assertEquals(-10, (Object)pq2.peek()); &#125;&#125; Heapifyinput: an int array.output: none. A min heap must satisfy following property, for a list of n elements {k1, k2… ki…kn}, (ki &lt;= k2i, ki &lt;= k2i+1)或者(ki &gt;= k2i, ki &gt;= k2i+1), (i = 1, 2, 3, 4… n/2).In other words, left child (node * 2 + 1) right child (node * 2 + 2)must not greater than node. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Heapify &#123; /** * @param A: Given an integer array * @return: nothing */ public void heapify(int[] A) &#123; // write your code here if (A == null || A.length &lt;= 1) &#123; return; &#125; for (int i = A.length / 2; i &gt;= 0; i--) &#123; shiftDown(A, i); &#125; &#125; private void shiftDown(int[] arr, int curr) &#123; int length = arr.length; while (curr &lt; length) &#123; int smallestIndex = curr; int leftChild = curr * 2 + 1; int rightChild = curr * 2 + 2; if (leftChild &lt; length &amp;&amp; arr[leftChild] &lt;= arr[smallestIndex]) &#123; smallestIndex = leftChild; &#125; if (rightChild &lt; length &amp;&amp; arr[rightChild] &lt;= arr[smallestIndex]) &#123; smallestIndex = rightChild; &#125; //whether curr is smaller than its children or curr is leaf; if (smallestIndex == curr) &#123; break; &#125; swap(arr, smallestIndex, curr); //from current node down curr = smallestIndex; &#125; &#125; private void swap(int[] arr, int one, int two) &#123; int temp = arr[one]; arr[one] = arr[two]; arr[two] = temp; &#125;&#125; Merge K Sorted Listsinput: lists of sorted linked list.output: one sorted linked list. The most intuitive way of solving this problems is that merge lists two by two. Since there are soreted linked list, recursively call a helper function and merge. Problem is that every node is visited more than one time.Another approach is using heap. Only keep the reference of head of the linked list. It taks O(k) to build min heap. Offer and poll operation take O(lok). There a k lists and every list has n nodes. The time complexity is O(knlogk). Space complexity is O(k) for list nodes in the priority queue. 12345678910111213141516171819202122232425262728293031323334public class MergeKLists &#123; /** * @param lists: a list of ListNode * @return: The head of one sorted list. */ public ListNode mergeKLists(List&lt;ListNode&gt; lists) &#123; if (lists == null || lists.size() == 0) &#123; return null; &#125; ListNode dummy = new ListNode(-1); ListNode newHead = dummy; PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(lists.size(), new Comparator&lt;ListNode&gt;()&#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val &lt; o2.val ? -1 : (o1.val == o2.val ? 0 : 1); &#125; &#125;); for (ListNode node : lists) &#123; if (node != null) pq.offer(node); &#125; while (!pq.isEmpty()) &#123; ListNode cur = pq.poll(); newHead.next = cur; newHead = newHead.next; if (cur.next != null) &#123; pq.offer(cur.next); &#125; cur.next = null; &#125; return dummy.next; &#125; Merge K sorted arraysinput: list of sorted arrays.output: one sorted array. Similar to merge linked list. Only difference is that element in the array doesn’t have reference to its neightbor. Creating a cell class with all information about an element’s neighbor. Using priority queue to store first element of each row because the rows in the 2D array may not have the same number of column. The time complexity is O(Nlogk) where N is the totol number of input and k is the number of arrays. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647ublic class MergeKArrays &#123; class Cell &#123; int val, row, col; public Cell(int val, int row, int col) &#123; this.val = val; this.row = row; this.col = col; &#125; &#125; /** * @param arrays * @return */ public int[] mergekSortedArrays(int[][] arrays) &#123; if (arrays == null || arrays[0] == null || arrays.length == 0 || arrays[0].length == 0) &#123; return new int[]&#123;&#125;; &#125; PriorityQueue&lt;Cell&gt; pq = new PriorityQueue&lt;&gt;(arrays.length, new Comparator&lt;Cell&gt;() &#123; @Override public int compare(Cell o1, Cell o2) &#123; return o1.val &lt; o2.val ? -1 : o1.val == o2.val ? 0 : 1; &#125; &#125;); //O(array.length) int length = 0; for (int i = 0; i &lt; arrays.length; i++) &#123; pq.offer(new Cell(arrays[i][0], i, 0)); length += arrays[i].length; &#125; int index = 0; int[] result = new int[length]; while (!pq.isEmpty()) &#123; Cell cur = pq.poll(); result[index++] = cur.val; if (cur.col + 1 &lt; arrays[cur.row].length) &#123; pq.offer(new Cell(arrays[cur.row][cur.col + 1], cur.row, cur.col + 1)); &#125; &#125; return result; &#125;&#125; High Fiveinput: list of Records with id and score.output: return the average of top 5 score for each id. Extra data structure needs to be used here to record scores for each id, and the average of score for the id. Using two maps, for list of scores, and another one for final result.It asks top 5 score. Intuitively, top number of something fits the property of max heap. Using priority queue to record scores, calculate averate of top 5 numbers. Time compexity is O(n) for store all data from the input. O(knlogn) for poping k times (5) for each id, and calculate the average. Therefore, the total time complexity is O(knlogn). Space used here besides the ouput is the map that used to store data, which is O(n). 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * public class Record &#123; * public int id, score; * public Record(int id, int score)&#123; * this.id = id; * this.score = score; * &#125; * &#125; */public class HighFive &#123; /** * @param results * @return */ public Map&lt;Integer, Double&gt; highFive(Record[] results) &#123; if (results == null) &#123; return new HashMap&lt;&gt;(); &#125; Map&lt;Integer, Double&gt; map = new HashMap&lt;&gt;(); Map&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; score = new HashMap&lt;&gt;(); for (Record record : results) &#123; if (!score.containsKey(record.id)) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 &gt; o2 ? -1 : o1 == o2 ? 0 : 1; &#125; &#125;); pq.offer(record.score); score.put(record.id, pq); &#125; else &#123; score.get(record.id).offer(record.score); &#125; &#125; for (Map.Entry&lt;Integer, PriorityQueue&lt;Integer&gt;&gt; pair : score.entrySet()) &#123; PriorityQueue&lt;Integer&gt; pq = pair.getValue(); int count = 0; double sum = 0; while (!pq.isEmpty() &amp;&amp; count &lt; 5) &#123; sum += pq.poll(); count++; &#125; map.put(pair.getKey(), sum / count); &#125; return map; &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure IV Queue]]></title>
    <url>%2F2018%2F05%2F05%2FData-Structure-IV-Queue%2F</url>
    <content type="text"><![CDATA[QueueA first in First out(FIFO) linear data structure. It allows insertion from onside and deletion from the other. Peek represents the first element added into the queue. Use to deal with process that has to be executed in a line. LinkedListImplement a queue with basic operations using linked list. Keep two references head and tail. Enqueue from the tail of the list, beacuse the head if the first element added in. Thus, dequeue from the head of the list. Time complexity for enqueue and dequeue are both O(1). Space complexity is O(1) beacuse only refernces are used.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MyQueueLL &#123; /** * public class ListNode&lt;Integer&gt;&#123; * public Integer val; * public ListNode next; * public ListNode(int val) &#123; * this.val = val; * this.next = null; * &#125; */ private ListNode head; private ListNode tail; int size; public MyQueueLL() &#123; head = tail = null; &#125; public void enqueue(Integer e) &#123; ListNode node = new ListNode(e); if (tail == null &amp;&amp; head == null) &#123; head = tail = node; &#125; tail.next = node; tail = tail.next; size++; &#125; public Integer dequeue() &#123; if (head == null) &#123; return null; &#125; ListNode node = head; head = head.next; size--; return node.val; &#125; public Integer peek() &#123; return head == null ? null : head.val; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; Circular ArrayImplement a queue by using an array. cyclic buffer or ring buffer is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. Using two pointers head and tail to represent two ends of the queue. If head == tail, the queue is either empty or full. Since the queue has its capacity, it needs a method to check whehter is full. The time complexity ans space complexity for enqueue and dequeue are both O(1). Data used here is just an Integer array. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyQueueArr &#123; Integer head; Integer tail; int size; Integer[] array; public MyQueueArr(int cap) &#123; array = new Integer[cap]; size = 0; head = tail = 0; &#125; public boolean enqueue(int e) &#123; if (size == array.length) &#123; return false; &#125; array[tail] = e; tail = tail + 1 == array.length ? 0 : tail + 1; return true; &#125; public Integer dequeue() &#123; if (size == 0) &#123; return null; &#125; Integer result = array[head]; head = (head + 1) % array.length; size--; return result; &#125; public int size () &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public boolean isFull() &#123; return size == array.length; &#125;&#125; Circular array initializes a capacity, and linked list doesn’t have the problem. Therefore, the use case for implementing queue by using array and linked list is that when the capacity of the queue is definite, using circurlar array. Otherwise, linked list is more flexible on the size of queue.]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>data structure</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure VI Graph II]]></title>
    <url>%2F2018%2F05%2F05%2FData-Structure-VI-Graph-II%2F</url>
    <content type="text"><![CDATA[A directed graph (or digraph) is a set of vertices and a collection of directed edges that each connects an ordered pair of vertices. We say that a directed edge points from the first vertex in the pair and points to the second vertex in the pair1. Directed GraphTopological sortGiven a digraph, put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order (or report that doing so is not possible). Remarkably, a reverse postorder in a DAG provides a topological order2. Proposition: A digraph has a topological order if and only if it is a DAG. Proposition: Reverse postorder in a DAG is a topological sort3. Applications: order of items that have dependencies from each other. Steps: Get in-degrees, and initialize topoligical list. Generate all elements that have 0 in-degree into queue. Expand elements and add into topological list. Reduce 1 in-degree from expanded elements. If in-degree of an element becomes 0, put into queue. If queue is empty, return.Time complexity is O(E + V) where E is edges and V is vertices. Space complexity is O(E) beaucse using queue123456789101112131415161718192021222324252627282930313233343536373839public class TopologicalSort &#123; public ArrayList&lt;DirectedGraphNode&gt; sort(ArrayList&lt;DirectedGraphNode&gt; graph) &#123; if (graph == null) &#123; return new ArrayList&lt;&gt;(); &#125; HashMap&lt;DirectedGraphNode, Integer&gt; map = new HashMap&lt;&gt;(); for (DirectedGraphNode node : graph) &#123; for (DirectedGraphNode nei : node.neighbors) &#123; if (map.containsKey(nei)) &#123; map.put(nei, map.get(nei) + 1); &#125; else &#123; map.put(nei, 1); &#125; &#125; &#125; ArrayList&lt;DirectedGraphNode&gt; list = new ArrayList&lt;&gt;(); Queue&lt;DirectedGraphNode&gt; queue = new ArrayDeque&lt;&gt;(); for (DirectedGraphNode node : graph) &#123; if (!map.containsKey(node)) &#123; queue.offer(node); list.add(node); &#125; &#125; while (!queue.isEmpty()) &#123; DirectedGraphNode cur = queue.poll(); for (DirectedGraphNode node : cur.neighbors) &#123; map.put(node, map.get(node) - 1); if (map.get(node) - 1 == 0) &#123; queue.offer(node); list.add(node); &#125; &#125; &#125; return list; &#125;&#125; 1.Sedgewick, Robert, and Kevin Daniel Wayne. Algorithms. Addison-Wesley, 2015. ↩2.Sedgewick, Robert, and Kevin Daniel Wayne. Algorithms. Addison-Wesley, 2015. ↩3.Sedgewick, Robert, and Kevin Daniel Wayne. Algorithms. Addison-Wesley, 2015. ↩]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生日]]></title>
    <url>%2F2018%2F05%2F04%2F%E7%94%9F%E6%97%A5%2F</url>
    <content type="text"><![CDATA[今年的生日, 想做一点不一样的事情, 保留一点点的仪式感. 从我记事儿开始, 家里的食物总是分成”大人的”和”小孩子的”. 比如我的馒头, 包子, 饺子, 馅儿饼个头儿都比较小; 我喜欢的蔬菜和肉的种类会放在我自己的碗盘里面, 小巧又精致. 其实是父母为了解决我小时候不爱吃饭的一种方式. 后来渐渐了, 我自己也养成了这样矫情的毛病. 一直到现在, 母亲包饺子依然是先包一部分小小的给我, 然后再包正常尺寸的. 这是我一直以来知道的细节, 因为习惯了, 也因为我本身是会做饭的, 所以也没觉得有什么. 小的时候, 父母亲工作忙, 所以我差不多上小学的时候就已经会做饭了. 包饺子这事儿自然也不在话下. 可是我从来没有独立的做完过整个流程. 因为觉得麻烦, 也因为当我觉得麻烦又想吃饺子的时候父母亲总会把饺子煮好端上桌. 去年, “怕麻烦”这个习惯, 终于还是让我吃了一堑. 我决定要改掉这个坏习惯. 就从这件小事儿开始. 于是我去超市买了材料, 自己从和面, 拌馅儿, 到擀皮儿, 包饺子. 整整站着忙了3个半钟头, 没有停下来过. 以至于有那么一小段时间累的耳鸣. 一开始还能按照自己的爱好, 包一些小巧可爱的, 保持饺子整体的干净整洁. 差不多包到一半的时候明显感觉饺子的个头儿越来越大, 馅儿都沾到外面了也懒得去清理了. 心里仅存的念头是”赶紧把剩下的馅儿包完”. 父母的爱都是在稀松平常的一餐一饭中. 这样看似简单的事情, 他们为了我坚持了二十多年. 哪有什么现世安稳, 不过是因为有人为你负重前行.]]></content>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Observer Pattern]]></title>
    <url>%2F2018%2F04%2F29%2FObserver-Pattern%2F</url>
    <content type="text"><![CDATA[观察者模式: 定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并自动更新1. 我的理解是, 每一个类都可以派一个哨兵, 也就是观察者去目标类进行卧底, 一旦目标状态发生变化或者有任何动作, 哨兵负责把状态返回. 就像小时候每个班都有一个坐在后门看放哨的同学. 目标类可以继承多个观察类, 对于同一个目标的状态改变, 不同的观察类可以返回不同的状态, 从而达到对于同一个目标产生多个不同的响应. 目标不需要通知哨兵, 它的状态发生变化了, 而每个哨兵之间的关系也是相对独立的, 从而达到了减少耦合的效果. 这种设计模式适用于, 一个对象的改变会影响到其他对象, 但是不知道具体有那些对象或者有多少对象会受到影响. 所以这些对象之间的关系不能够是相互依赖的. 目标类需要做的事情就是: 继承观察类. 增加/删除将会受到影响的对象. (增加删除对象的时候不影响其他观察者) 观察类需要做的事情就是: 提供一个通知更新的接口. 这样就可以实现, 重复使用目标类和观察类, 而不影响其他对象. 最早的可能也是最著名的 Observer 模式的例子出现在 SmallTalk 的 MVC 结构中,它是 SmallTalk 环境[KP88] 中的用户界面框架. MVC 的 Model 类担任目标的角色, 而 View 类是观察者的 base class. SmallTalk, ET++[WGM88], 和 THINK 类库[sym93b]都将 Subject 和 Observer 的接口放入系统所有其他类的父类中, 从而提供一个通用的依赖机制. 其他使用这一模式的用户界面工具有 InterViews[LVC89], AndrewToolkit[p+88] 和 Unidraw[VL90]. InterViews 显示地定义了 Observer(观察类) 和 Observable (目标类). Andrew 分别称它们为”视图”和”数据对象”. Unidraw 将图形编辑器对象分割成 View 和 Subject 两部分2. 安卓界面中大量的使用了 Observer, 通过继承 activity 和 Fragment 的观察类, 主程序状态会被在不同的组件进行更新.]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>Design Pattern</tag>
        <tag>Observer Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Search]]></title>
    <url>%2F2018%2F04%2F25%2FBinary-Search%2F</url>
    <content type="text"><![CDATA[Binary search is a search algorithm. The fundamental is that it reduces the searching range into half each time by comparing the middle element to the target. Normal binary search takes O(logn) comparisons, when n is the number of input. Space actually depends on the implementation. If not using recursion, there would be no extra space used in a regular binary search. Therefore, it normally is O(1). Key concept: Input must be in some sort of order (ascending, descending, alphabetic, positve and nagative, increased then descrease, etc.) Searching/calculation/operating range must be reduced each time. Targe must not be ruled out. Classic Binary Searchinput: A sorted array and a target.output: Index of the target if exits, otherwise, return -1; IterationTime complexity is O(logn), where n is the size of input. Space is O(1) using iteration.12345678910111213141516171819202122232425public class BinarySearch &#123; /** * @param array * @param target * @return */ public int binarySearch (int[] array, int target) &#123; if (array == null || array.length == 0) return -1; int left = 0, right = array.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (array[mid] == target) &#123; return mid; &#125; //other wise mid is not the result, rule it out. if (array[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; //if not return in the while loop, target doesn't exist. return -1; &#125;&#125; RecursionTime complexity is the same as O(logn). Call stack counts as space expense, which is O(logn). 12345678910111213141516171819202122232425public class BinarySearch &#123; /** * @param array * @param target * @return */ public int binarySearch (int[] array, int target) &#123; if (array == null || array.length == 0) return -1; return helper(array, 0, array.length - 1, target); &#125; private int helper(int[] array, int left, int right, int target) &#123; if (left &gt; right) return -1; int mid = left + (right - left) / 2; if (array[mid] == target) return mid; //if not return, mid is not target, can rule out mid. if (array[mid] &gt; target) &#123; return helper(array, left, mid - 1, target); &#125; else &#123; return helper(array, mid + 1, right, target); &#125; &#125;&#125; Search a 2D Matrix Iinput: A matrix that each row is in ascending order, and the first element of each row is greater than the last element of previous row. A int type target.output: The coordinate of the target if exists. Otherwise, return -1. One way to solve this problem by using binary search is convert 2D matrix into an array. Due to the property of the matrix, from left to right, top to buttom, all elements are in ascending order. Therefore, it will be able to use the classic binary search. The time complexity is O(n + m) where n is the number of row and m is the number of colmun. Space complexity is O(1). No extra data structure is used. 12345678910111213141516171819202122232425262728public class Search2DMatrix &#123; /** * @param matrix * @param target * @return */ public int searchMatrixI (int[][] matrix, int target) &#123; if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0) return -1; int row = matrix.length; int column = matrix[0].length; int left = 0, right = row * column - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; int x = mid / column, y = mid % column; if (matrix[x][y] == target) &#123; return matrix[x][y]; &#125; if (matrix[x][y] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; &#125;&#125; Search in a Unknown Size Arrayinput: An unknwon size array in ascending order, you can only access the kth number by ArrayReader.get(k). A target number.output: return the first occurrence of the target. Only thing differnce from classic bianry search is right boundary. While checking the right boundary, set the left boundary where is the last position that the element is smaller than the target. Jumping 2 times of the current element to locate the right boundary, then the time complexity is O(logk + O(logn)) where k is the element from the left boundary to the right boundary, n is the number of elements preceding the left boundary.The only reason jumping 2 times instead of a larger one is beacuse the final time complexity is difference only in coefficient. The size is unknwon. If there are only a few of elements in the array, jumping 10 times or 20 times would be out of bounds. It is not worth to take the risk. 1234567891011121314151617181920212223242526272829303132public class SearchUnknownSize &#123; /** * @param reader: An instance of ArrayReader. * @param target: An integer * @return: An integer which is the first index of target. */ public int searchBigSortedArray(ArrayReader reader, int target) &#123; if (reader == null) &#123; return -1; &#125; //locate right boundary int right = 1; int left = 0; while (reader.get(right - 1) &lt; target) &#123; right *= 2; left = right; &#125; //binary search for first occurrence while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (reader.get(mid) &gt;= target) &#123; right = mid; &#125; else if (reader.get(mid) &lt; target) &#123; left = mid + 1; &#125; &#125; if (reader.get(left) == target) return left; if (reader.get(right) == target) return right; return -1; &#125;&#125; First Bad LogThe concept is using binary search to find the left and right boundary, and locate the first occurrence of the bad log. Search Insert Positioninput: an integer array and a target number.output: return the index if the target is found. If not, return the index where it would be if it were inserted in order. It is easier to find a closest number to the target, then compare the element to the target, insert target at the position it if the element is greater or equal to the target. insert target after the position if the element is smaller than the target. The time comlexity is O(logn). Space complexity is O(1). 1234567891011121314151617181920212223242526272829303132public class searchInsert &#123; /** * @param input: an integer sorted array * @param target: an integer to be inserted * @return: An integer */ public int searchInsert(int[] input, int target) &#123; // write your code here if (input == null || input.length == 0) &#123; return 0; &#125; int left = 0; int right = input.length - 1; //keep one element for comparing to the target. while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &gt;= target) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; if (input[left] &gt;= target) &#123; return left; &#125; return left + 1; &#125;&#125; First Occurrence of Targetinput: an sorted int array in ascending orderoutput: index of the first occrrence of the target. If not exist, return -1;I’d like call it look to the left. Using binary search, if greater or equal, set the right boundary at the position. If less than the target, the element is excluded from searching range.Time comlexity is O(logn), space is O(1). 12345678910111213141516171819202122public class FirstOccurrence &#123; /** * @param input * @param target * @return first occurrence of the target */ public int firstOccurrence(int[] input, int target) &#123; if (input == null) return -1; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &gt;= target) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; if (input[left] == target) return left; return right; &#125; &#125; Last Occurrence of Targetinput: an sorted int array in ascending orderoutput: index of the last occurrence of the target. If not exisit, return -1. I’d like call it look to the right. Similar to first occurrance. Only difference is if the element at the middle is less than or equal to the target, set the left boundary, because right result must be in the range from the position to the end. If the middle element is greater than the target, it is eliminated from the result. Time comlexity is O(logn), space is O(1).12345678910111213141516171819202122public class LastOccurrence &#123; /** * @param input * @param target * @return first occurrence of the target */ public int lastOccurrence(int[] input, int target) &#123; if (input == null) return -1; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt;= target) &#123; left = mid; &#125; else &#123; right = mid - 1; &#125; &#125; if (input[right] == target) return right; return left; &#125;&#125; Total Occurrence of Targetinput: an int array in ascending order and a target number.output: return the total occurrence of the target. One way to do it is, targeting either the first occurrence or the last occurrence of the target. The look throught it and count. The time complexity would be O(logn) for finding the position and O(k) for looping the number of target, so it is O(logn + k). Space comlexity is O(1). Another way of calculating the number of target in the array is to get both first occurrence and the last occurrence of the larget. Using the last position minus the first position and plus 1 to get the total number of target in the array. The time complexity is O(2logn). Space Comlextiy is O(1). Which ways is bettern actually depending on the number of target, k. If all elements in the array are the same numbers. For example, {1, 1, 1, …, 1, 1}. The first method becomes O(n). The second method remains the same. However, if k is a really small number, then the first method is better.1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TotalOccurrence &#123; /** * @param input: an integer array sorted in ascending order * @param target: An integer * @return: An integer */ public int totalOccurrence(int[] input, int target) &#123; if (input == null || input.length == 0 || input[0] &gt; target || input[input.length - 1] &lt; target) &#123; return 0; &#125; int left = 0, right = input.length - 1; //left boundary while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &gt;= target) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; //退出条件是一个元素, 如果不等于 target, 则 target 不存在. if (input[left] != target) return 0; //left boundary and right boundary int start = left, end = input.length - 1; //right boundary right = end; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt;= target) &#123; left = mid + 1; end = mid; &#125; else &#123; right = mid - 1; &#125; &#125; return end - start + 1; &#125;&#125; Search for a RangeAs same as total occurance, only changes the return type to a new int[]{start, end}.Time and space comlexity are the same, too. Closest Number to Targetinput: An integer array and an integer target number.output: return the number that closest to the target. Time complexity is O(logn). Space complexity is O(1). Using binary search and reducing the candidate to two elements. Whichever closer to target is the result.123456789101112131415161718192021222324public class ClosestNumber &#123; /** * @param input an integer array sorted in ascending order * @param target an integer * @return an integer */ public int closestNumber(int[] input, int target) &#123; if (input == null || input.length == 0) &#123; return -1; &#125; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt;= target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; return Math.abs(input[left] - target) &lt; Math.abs(input[right] - target) ? left : right; &#125;&#125; Search in Rotated Sorted Array Iinput: a sorted array is rotated at some unknown pivot and a target number. (No duplicates)output: return the index of target if exists. Otherwise, return -1. Since the array is still sorted in a way, it still can use binary search. The middle element has 3 situations: it is the target it is in an rotated interval (greater than the right most element) it is greater than the target, target could be in both side of the array. it is less than target, set the left boundary. it is in an unrotated interval (smaller than the right most element) it is greater than the target, set the right boundary. it is less than the target, target could be in both side of the array.This problem actually would be more straitforwar if looking at a picture. The time complexity is as same as classic binary search, O(logn), although it has more conditions. Space complexity is O(1).1234567891011121314151617181920212223242526272829303132333435363738public class RoatedSortedArrayI &#123; /** * @param input * @param target * @return */ public int search(int[] input, int target) &#123; if (input == null || input.length == 0) &#123; return -1; &#125; int left = 0, right = input.length - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (input[mid] == target) &#123; return mid; &#125; //第一个上升区间 if (input[mid] &gt; input[right]) &#123; if (input[mid] &gt; target &amp;&amp; target &gt; input[right]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; //第二个上升区间 if (input[mid] &lt; input[left]) &#123; if (input[mid] &lt; target &amp;&amp; target &lt; input[left]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125; Search in Rotated Sorted Array IIinput: rotated array with duplicates.output: index of target. Fist of all, run a for loop searching target takes O(n). If the array is rotated with duplicates, it takes redundant checks to determine whether the middle point is in which interval. For example, {1, 1, 1, 1, 1, 0, 1, 1, 1}. The time complexity would be O(n) the worst case. Therefore, just simply run a loop. 123456789101112131415161718192021public class SearchRotateArrayII &#123; /** * @param input: an integer ratated sorted array and duplicates are allowed * @param target: An integer * @return: index */ public int search(int[] input, int target) &#123; if (input == null) &#123; return -1; &#125; for (int i = 0; i &lt; input.length; i++) &#123; if (input[i] == target) &#123; return i; &#125; &#125; return -1; &#125;&#125; Find Peak Elementinput: An integers array that the numbers in adjacent positions are different. A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1]. Peak in an array: A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1]output: return any of peek positions. There might be more than one peeks. According to the definition of the peek and the array’s feature. Returning any peek can use a binary saerch. Since the array is kind of sorted, the middle point would have three situations. middle point is the peek middle point is in the left side of a peek, then it’s in ascending order (like going uphill) middle point is in the right side of a peek, then it’s in descending order (like going downhill) Time comlexity is O(logn). Space complexity is O(1). If using ‘left + 1 &lt; right’ as the condition of the while loop, it eliminates many checkings for index out of bounds excemption. The element always needs to compare with its neighbor, so it’s easier to keep at least three elements during the comparing. Making sure that the peek would not be ruled out guarantees the greater element to be the peek when finishing the loop. 12345678910111213141516171819202122232425262728293031public class FindPeek &#123; /** * @param input: An integers array. * @return: return any of peek positions. */ public int findPeak(int[] input) &#123; if (input == null || input.length &lt; 3) &#123; return -1; &#125; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; /*if (input[mid] &gt; input[mid - 1] &amp;&amp; input[mid] &gt; input[mid + 1]) &#123; return mid; &#125;*/ //at ascending interval if (input[mid] &gt; input[mid - 1]) &#123; left = mid; &#125; //at descending interval if (input[mid] &lt; input[mid - 1]) &#123; right = mid; &#125; &#125; if (input[left] &gt; input[right]) &#123; return left; &#125; return right; &#125;&#125; Maximum Number in Mountain Sequenceinput: An integer array which increase firsly and then decreses.output: return the mountain top. Actually the same question as find peek. T = O(logn), S = O(1). Comparing an element to its neighbor is always easier to keep at least 3 elements. It saves many index boundary check. Notice that left or right boundary could be the candidate of the result, it should not be eliminated. 12345678910111213141516171819202122232425public class MountainTop &#123; /* * @param input: a mountain sequence which increase firstly and then decrease * @return: then mountain top */ public int mountainSequence(int[] input) &#123; if (input == null || input.length == 0) &#123; return 0; &#125; int left = 0, right = input.length - 1; while (left + 1 &lt; right) &#123; int mid = left + (right - left) / 2; if (input[mid] &lt; input[mid + 1]) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; return Math.max(input[left], input[right]); &#125;&#125; Find Minimum in Rotated orted Array IThis question is actually as same as finding the peek. Find Minimum in Rotated orted Array IIAs same as duplicates in a rotated sorted array, it is not worth to use binary search with all redundant checks. Single Number IVinput: an int array with all the numbers appear twice except one number which appears once and all the numbers which appear twice are next to each other.output: find the number that appears once. 找出单身狗🤣 Intuitive way is using a set. Beacuse of the property of set, if there exisit the element, remove the element. The one left in the set would be the result. Time comlexity is O(n), and space complexity is about O(n) during the comparing. However, this would waste the clue that “same numbers appear next to each other”. Since the intutitive way takes only O(n), optimized method ought to be better than that. Since there is only 1 missing number, then the number element of the input must be odd.There are 2 cases of the middle number. the middle number is the missing number. the middle number has an ajacent duplicate number. The adjacent number with the same value is in the left side. the adjacent number with the same value is in the right side. The key point is, the side that has the odd number of element after eliminating the middle pair has the missing number. Time comlexity is O(logn). Space comlexity is O(1).1234567891011121314151617181920212223242526272829303132333435public class MissingNumberIV &#123; /** * @param nums * @return the lonely number */ public int getSingleNumber(int[] nums) &#123; if (nums == null || nums.length == 0 || nums.length % 2 == 0) return -1; if (nums.length == 1) return nums[0]; //if not return, the array has at lest 3 elements. int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; //和右边相等的话, 右边减去1 是不是偶数 if (nums[mid] == nums[mid + 1]) &#123; if ((right - mid - 1) % 2 == 0) &#123; right = mid - 1; &#125; else &#123; left = mid + 2; &#125; &#125; else if (nums[mid] == nums[mid - 1]) &#123; if ((mid - left - 1) % 2 == 0) &#123; left = mid + 1; &#125; else &#123; right = mid - 2; &#125; &#125; else &#123; return nums[mid]; &#125; &#125; return nums[left];/// &#125;&#125; Power(x, n)input: two integers.output: return the power of the first number. There are several cases need to concern in the arithmetical opeation: overflow base is 0 if exponent &lt;= 0, error if exponent &gt; 0, return 0 exponent is 0, return 1 exponent is negative, 1 / result exponent is positive, exponent is even number exponent is odd number Using recursion to reduce the power. a to the power of b can be divided into a to the half of power of b times a to the half of power of b. And so on and so forth. The complexity is O(logb). Space compexity is O(logb) due to the call stack. 123456789101112131415161718192021222324252627282930public class PowerAB &#123; /** * @param a * @param b * @return */ public double power (int a, int b) &#123; if (a == 0) &#123; if (b &lt;= 0) &#123; throw new IllegalArgumentException("Illegal input"); &#125; return 0; &#125; if (b &lt; 0) &#123; return 1 / helper(a, -b); &#125; return helper(a, b); &#125; private double helper(int a, int b) &#123; if (b == 0) &#123; return 1; &#125; double half = helper(a, b / 2); if (b % 2 == 0) &#123; return half * half; &#125; return half * half * a; &#125;&#125; Divide Two Integersinput: two itnegersoutput: divide two integers without using multiplications, division and modulo. Using divisor to reduce the number of dividend to get the result. Counting how many dividend has been detracted1. Similar as doing power of two integers, using binary concept to accelerate the process2. Time complexity is O(logn) where n is the divisor and the space complexity is O(1). 123456789101112131415161718192021222324252627282930313233343536373839public class DivideTwoIntegers &#123; /** * @param dividend * @param divisor * @return */ public int divide(int dividend, int divisor) &#123; if (dividend == 0) &#123; throw new IllegalArgumentException("Dividend cannot be 0."); &#125; if (divisor == 0) &#123; return dividend &lt; 0 ? Integer.MIN_VALUE : 0; &#125; if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) &#123; return Integer.MAX_VALUE; &#125; boolean isNegative = (dividend &lt; 0 &amp;&amp; divisor &gt; 0 || dividend &gt; 0 &amp;&amp; divisor &lt; 0); long absDividend = Math.abs((long) dividend); long absDivisor = Math.abs((long) divisor); long result = 0; while (absDividend &gt;= absDivisor) &#123; int shift = 0; while (absDividend &gt;= (divisor &lt;&lt; shift)) &#123; shift++; &#125; dividend -= divisor &lt;&lt; (shift - 1); result += 1 &lt;&lt; (shift - 1); &#125; return isNegative ? (int) -result : (int) result; &#125;&#125; Find Smallest Letter Greater Than Target (LeetCode 744)input: a char array of sorted letters containing only lowercase letters, and given a target letter target.output: return the smallest element in the list that is larger than the given target. Letters are ordered is ideal for binary search. Time complexity is O(logn). Space is O(1). Keep one element that is greater than the target. If the characters is less than or equal to target, target must closer to the first element in the array. Otherwise, the character is the result. 1234567891011121314151617181920212223public class SmallestGreaterLetter &#123; /** * @param letters * @param target * @return */ public char nextGreatestLetter(char[] letters, char target) &#123; if (letters == null) return ' '; int left = 0, right = letters.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (letters[mid] &lt;= target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; if (letters[left] &lt;= target) return letters[0]; return letters[left]; &#125;&#125; &lt;!– ### Count of Smaller Numberinput: an integer array and a query list.output: return the number of element in the array that are smaller than the given number in the query. 続く。 1.https://blog.csdn.net/fightforyourdream/article/details/16899675 ↩2.http://www.cnblogs.com/yuzhangcmu/p/4049170.html ↩]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Emoji]]></title>
    <url>%2F2018%2F04%2F25%2FEmoji%2F</url>
    <content type="text"><![CDATA[最近、私は絵文字に耽っていてかわいいと面白い絵文字をたくさん見つけましたが、実際は言葉や記号で表現された表現なので、「mojie」と呼ぶ方が適切かどうかはわかりませんでしょう。(ˊo̴̶̷̤⌄o̴̶̷̤ˋ)私はね、実際は、長い間日本語を使いませんでした。これらの文章を書いたこと、多くの辞書をチェックしましたが、文法上の問題はまだあると思います。まあぁ、いい。それじゃあ〜 ( ¤̴̶̷̀ ·̫ ¤̴̶̷́ )(๑¯◡¯๑)(ง •̀•́)ง(๑॔ᵒ̴̶̷◡ ˂̶๑॓)ゞ❣୧(๑•̀⌄•́๑)૭✧✧୧(๑=̴̀⌄=̴́๑)૭✧⊂(˃̶͈̀ε ˂̶͈́ ⊂ )))Σ≡=─✧⁺⸜(●˙▾˙●)⸝⁺✧(๑✦ˑ̫✦)✨๑乛◡乛๑╮(๑•́ ₃•̀๑)╭(..•˘˘•..)(๑ᵒ̴̶̷͈᷄ᗨᵒ̴̶̷͈᷅)(｡•ˇ‸ˇ•｡)(⁎⁍̴̛ᴗ⁍̴̛⁎)(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ୧( ⁼̴̶̤̀ω⁼̴̶̤́ )૭]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Data Structure VI Graph I]]></title>
    <url>%2F2018%2F04%2F24%2FData-Structure-VI-Graph-I%2F</url>
    <content type="text"><![CDATA[A graph is formed by the non-empty set of vertex and set of edge. Use G &lt;E, V&gt; to represent a graph, G, and the sets of it’s vertex, V, and edge, E. Undirected GraphA graph is a set of vertices and a collection of edges that each connect a pair of vertices Representation of Graph Data Structure (common) Ajacentcy Matrix: using a 2D array to indicate the relationship between vertex (row) and edge (column). Uses O(n^2) space for a sparse graph, not recommended. Ajacentcy List: Array of array to represent the relationship between the vertex (index), and the edge (array corresponds to the index). Even though the worst case of space using is still O(n^2), normally is better than ajacentcy matrix. Map&lt;T, Set&lt;T&gt;&gt;, where T is the vertext and Set is the set of edge. (Java) Class of GraphNode, which has two main field, the vertext and the list of its neighbors.(Java)1234class GraphNode&#123; int vertexLabel; List&lt;GraphNode&gt; neighbors;&#125; Traverse a Graphinput: A graph node, assume that the graph is connected.output: A list of all nodes’ value in the graph. Unlike doing BFS on a tree, an extra data structure need to be used in traverse to avoid revisiting a node in a graph. Tree is a directed acyclic graph. If there are n nodes in a tree, there must be n - 1 edges, and every node can be visited from the root. Three main differences, A graph may or may not have direction. (better breadth first from one vertex) A graph may have circle. (markvisited) Nodes in a graph may not be connected. (all nodes must be given unless its connected) The data structure that widely used in BFS is queue, due to its FIFO property (in the order from left to right in a level). In a graph, node in the queue is the one that is waiting for expending. Meanwhile, set is saving all generated (visited/put in the queue) nodes. To sum, there are two common data structure involved in traversing a graph in general.(Java)Time complexity is O(v + e), where v is the number of vertex and e is the number of edge. Space is O(v), where v is the number of nodes because the worst case is to save all vertex. 12345678910111213141516171819202122232425262728293031public class Solution&#123; class GraphNode&#123; int label; List&lt;GraphNode&gt; neighbors; public GraphNode(int val) &#123; label = val; neighbors = new ArrayList&lt;GraphNode&gt;(); &#125; &#125; //Assume it's a connected graph public List&lt;Integer&gt; traverseGraph(GraphNode node) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (node == null) return result; Queue&lt;GraphNode&gt; queue = new LinkedList&lt;&gt;(); Set&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); queue.offer(node); visited.add(node); while (!queue.isEmpty()) &#123; GraphNode cur = queue.poll(); result.add(cur.label); for (GraphNode n : cur.neighbors) &#123; if (!visited.contains(n)) &#123; visited.add(n); queue.offer(n); &#125; &#125; &#125; return result; &#125;&#125; Clone Graphinput: A graph node, if the graph is connected, or a list of all nodes in the graph (easier).output: Deeped copyed node of new graph, or a list of all nodes that is copied. Similar to traverse a graph, except two more steps, Traverse the graph and get all nodes. (if not given) Copy all vertex(nodes) Copy all neighbors for every vertex. An extra data structure Map&lt;GraphNode, GraphNode&gt; is used here for mapping the original and copied node. Neighbors can be copied by tracing the key in the map. Time complexity is 3 times of traversal because at each step, all nodes need to be visited, so O(3(v + e)) is O(v + e).Space complexity is 2 times of traversal if list of node is not given. No matter the input form, the space complexity is going to be O(v), where v is the number of vertex. 1234567891011121314151617181920212223242526272829303132333435363738public GraphNode clone(GraphNode node) &#123; if (node == null) return null; //get node List&lt;GraphNode&gt; list = getNodes(node); //copy node, key is the original node, and create a same node as its value. Map&lt;GraphNode, GraphNode&gt; map = new HashMap&lt;&gt;(); for (GraphNode n : list) &#123; map.put(n, new Graph(n.label)); &#125; //copy neighbor/edge for (GraphNode ver : list) &#123; GraphNode newNode = map.get(ver); for (GraphNode nei : ver.neighbors) &#123; newNode.neighbors.add(map.get(nei)); &#125; &#125; return map.get(node); &#125;private List&lt;GraphNode&gt; getNodes(GraphNode node) &#123; Queue&lt;GraphNode&gt; q = new LinkedList&lt;&gt;(); Set&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); q.offer(node); visited.add(node); while(!q.isEmpty()) &#123; GraphNode cur = q.poll(); for (GraphNode nei : cur.neighbors) &#123; if (!visited.contains(nei)) &#123; q.offer(nei); visited.add(nei); &#125; &#125; &#125; return new ArrayList&lt;&gt;(visited);&#125; Sometimes, step/level/layer matters. Which means there needs to be a indicator for nodes that can be expanded from one. Just like BFS in a tree, use current size of the queue to detemine whether the nodes in the same level or not. There are other ways to indicate differnce levels in a graph, like two queues, indicator node, etc. I prefer more general way that can be used in both graph and tree. Traverse a Graph by Layerinput: A graph node, assume that the graph is connected.output: A list of list of all nodes’ value in the graph. Code is pretty similar to regular traversal, only add a for loop to track the number of nodes at the same level.The time comlexity doesn’t change. It is O(v + e), and the space is O(v) as same as traversal. 1234567891011121314151617181920212223242526272829303132333435363738public class Solution&#123; class GraphNode&#123; int label; List&lt;GraphNode&gt; neighbors; public GraphNode(int val) &#123; label = val; neighbors = new ArrayList&lt;GraphNode&gt;(); &#125; &#125; //Assume it's a connected graph public List&lt;List&lt;Integer&gt;&gt; traverseGraph(GraphNode node) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (node == null) return result; Queue&lt;GraphNode&gt; queue = new LinkedList&lt;&gt;(); Set&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); queue.offer(node); visited.add(node); while (!queue.isEmpty()) &#123; //size changes every time generates a node int size = queue.size(); List&lt;GraphNode&gt; level = new ArrayList&lt;&gt;(); //run loop for current size of the queue for (int i = 0; i &lt; size; i++) &#123; GraphNode cur = queue.poll(); level.add(cur.label); for (GraphNode n : cur.neighbors) &#123; if (!visited.contains(n)) &#123; visited.add(n); queue.offer(n); &#125; &#125; &#125; result.add(level); &#125; return result; &#125;&#125; There are more useful way of indicating levels while traversing. For example, find steps from one node to the other. Every level includes one more step towards to the target node. ShortestPath(monodirection)input: List of graph node, starting node, and target node. If given graph is not null, both start and end position are not null.output: Return the shortest path from the start to the target. If there is not such path, return -1. In an undirected graph, there are many ways to visualize a graph. For example, there is a graph has 10 nodes, and 12 edges, shown in the picture. It can ba organized to,看这销魂的走位(ง•̀-•́)งil suffit de prendre un noeud…こんなことも〜There is always a way to put some node in the same level from a start node as shown in the 2nd and third pictures. The only thing needs to be considered is how many levels or steps it takes until the target appears in the queue, then it is the final step to reach the target.Time comlexity is O(v + e) as same as regular reversal, and uses a set to avoid revisiting. And the space comlexity is the set that stores all visited node, which is O(v). 12345678910111213141516171819202122232425262728public int shortestPath(List&lt;GraphNode&gt; graph, GraphNode start, GraphNode target) &#123; if (graph == null) return -1; if (start == target) return 0; Queue&lt;GraphNode&gt; q = new LinkedList&lt;&gt;(); Ser&lt;GraphNode&gt; visited = new HashSet&lt;&gt;(); int step = 0; q.offer(start); visited.add(start); while (!q.isEmpty()) &#123; int size = q.size(); step += 1; for (int i = 0; i &lt; size; i++) &#123; GraphNode cur = q.poll(); for (GraphNode nei : cur.neighbors) &#123; if (nei == target) &#123; return step; &#125; if (!visited.contains(nei)) &#123; q.offer(nei); visited.add(nei); &#125; &#125; &#125; &#125; return -1;&#125; ShortestPath(bidirection)input: List of graph node, starting node, and target node. If given graph is not null, both start and end position are not null.output: Return the shortest path from the start to the target. If there is not such path, return -1. step plus one from each direction. In a regular traversal, the time comlexity is about the same as monodirection. And the space remains the same. It is beacuse, even though traversing from two direction “at the same time”, the total number of node in the graph is given.However, if each node expends X states at a level, and there are N levels. Then the time complexity is going to be X^N. Coming from two directions will reduce level to N/2 for each direction. The the time comlexity becomes 2 * X^(N/2), which optimizes about squareroot of the complexity. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public int shortestPath(List&lt;GraphNode&gt; graph, GraphNode start, GraphNode target) &#123; if (graph == null) return -1; if (start == target) return 0; Queue&lt;GraphNode&gt; qStart = new LinkedList&lt;&gt;(); Ser&lt;GraphNode&gt; visitedStart = new HashSet&lt;&gt;(); Queue&lt;GraphNode qTarget = new LinkedList&lt;&gt;(); Ser&lt;GraphNode&gt; visitedTarget = new HashSet&lt;&gt;(); int step = 0; qStart.offer(start); visitedStart.add(start); qTarget.offer(target); visitedTarget.add(target); while (!qStart.isEmpty() &amp;&amp; !q.target.isEmpty()) &#123; //from start int sizeStart = qStart.size(); step += 1; for (int i = 0; i &lt; sizeStart; i++) &#123; GraphNode cur = qStart.poll(); for (GraphNode nei : cur.neighbors) &#123; if (qTarget.contains(nei)) return step; if (!visitedStart.contains(nei)) &#123; qStart.offer(nei); visitedStart.add(nei); &#125; &#125; &#125; //from target int sizeTarget = qTarget.size(); step += 1; for (int i = 0; i &lt; sizeTarget; i++) &#123; GraphNode cur = qTarget.poll(); for (GraphNode nei : cur.neighbors) &#123; if (qStart.contains(nei)) return step; if (!visitedTarget.contains(nei)) &#123; qTarget.offer(nei); visitedTarget.add(nei); &#125; &#125; &#125; &#125; return -1;&#125; Onlything changed in bidirection traverse is adding a queue for the direction, and check whether current node expands a node in the queue of the other direction.&lt;!– Word Ladderinput: –&gt;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习笔记]]></title>
    <url>%2F2018%2F04%2F22%2FAndroid-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[生活不止有眼前的枸杞, 还有生发水和保温杯.这是一篇中英掺杂的学习笔记. MVC 设计模式view controller Model(data) 项目结构主要部分 MainActivity: 应用程序的入口, 当构建和运行程序是, 系统会启动这个 Activity 的实例并且加载布局(可以理解为构造函数吧…). Activity_main.xml: 对于每一个生成的 activity 模块, Android Studio 都会自动生成一个 xml 文件, 用来定义这个 Activity 的界面布局( list view, grid view, color, font, etc.). manifests –&gt; AndroidManifest.xml: 整个应用的布局以及每个组件的定义, 包括了 Activity, fragment 等等. build.gradle: 一个是用于项目的(app)配置, 另一个是用来应用模块的. drawable: 组件元素文件夹. 界面结构 ViewGroup: 其实就是 java 的一个类, 用来控制一个界面内的视图布局. View: 从源码可以看出, View实际上实现了一些界面组件的接口. 12public class View extends Object implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource Activity应用程序的一个组件.几乎所有的 Activity 都会创建一个可以和用户进行交互的界面. 像之前提到的, MainActivity 是应用程序的入口, 当用户启动这个程序的时候, 这个组件会生成一个主界面, 例如, 登陆界面等等. 一个程序可以拥有多个 Activity, 而他们之间可以相互调用. 调用的过程和普通程序的 call stack 差不多. 例如, 当 MainActivity 调用了其他 Activity 的之后, MainActivity 会停止, 但是仍然在 stack 中. 当被调用的 Activity 返回的时候, 栈顶元素被弹出并销毁, 之前的栈内元素会被恢复. 要确保”停止”, “生成界面”, “恢复”, “销毁”等功能, 就需要在创建 Activity 的时候实现这些方法. 因为和所有其他组件一样, Activity 也是 Java 中的一个类. 其中2个方法是必须要实现的, 生成界面(与用户交互), 和停止(暂停但是不销毁). onCreate() 相当于构造函数, 调用当前 Activity 的时候调用这个方法, 并且调用 setContentView() 来初始化用户界面. onPause() 被调用的新的 Activity 覆盖了之前的 Activity(不可见), 那个 Activity 存在栈中, 处于停止状态, 但是没有被销毁. 其他的方法例如, startActivity() , 通过调用 Intent 类型的对象来向其他 Activity 传递消息. startActivityForResult(), 需要从 Activity 返回某些数据/结果. 结果仍然通过 intent 传递. finish() 结束当前 Activity finishActivity() 结束之前的某一个 Activity. Activity 的生命周期 Intent组件之间的通讯, 包括启动 Activity, 启动 service, 传递 broadcast. 从 Activity 的方法实现上可以看出来, Intent 这个类型的对象可以携带数据.Intent是两个activity之间的信使，让一个activity传递消息/命令给另一个activity，最常用的就是让一个app里的activity和另一个app里的activity进行交流。 Intent有三个用途： start an activity (会使用UI） start a service （后端运行，不使用UI）1 deliver a broadcast to other apps 在1，2种用途中，我们可以使用： explicit intent， intent在初始化时就规定好了发送方和接收方e.g. Intent intent = new Intent(this, Hello.class); 发送方是this，也就是当前activity，接收方是一个叫Hello的activity implicit intent，intent在初始化时没有规定好发送方和接收方，但声明需求。Android系统中的activitymanager，会检查其他所有app声明文件中的intent filter，找出可以满足需求的activity，如果有多个满足条件，就弹出列表供用户选择。 但是，我们可以看出，不管是哪种intent，都只能执行“打开另一个activity/service“的能力，是因为接受方只有在onCreat()这一步的时候，才能接受intent，从而start。 而broadcast不同，它可以在activity的任何一步进入监听状态，它可以让activity做各种事情，而不局限于start。另外，它可以一对多，同时让多个activity响应（响应的实现方式为extends BroadcastReceiver, 以及在life cycle function中写入监听开始（register））。 总结：普通intent只能一对一，并只能执行start操作让activity/service启动broadcast可以一对多，并能让activity做各种事情。而且broadcast有分级别，系统级别的某些broadcast禁止普通app进行监听。2 Fragment3.0版本中引入, 为了应用在大屏幕设备上. Fragment 依赖于 Activity 存在, 但是拥有自己的生命周期, 拥有独立的输入事件的响应. 一个 Activity 可以包含多个 Fragment, 同一个 fragment 也可以被不同的 activity 调用. 尤其适用于 Single Activity 应用. 可以把 Fragment 看做是可以被重复使用的模块. 可以做为 activity 的一部分, 多个 fragment 出现在同一个 activity 里面, 或者一个 fragment 在不同的 activity 出现. 处于同一个 Activity 下面的多个 Fragment 可以通过 Activity 进行通讯, 而 Activity 之间需要 intent 或者 broadcast 来进行通讯. Activity 运行中可以添加, 删除或者替换 fragment. Fragment 拥有自己的生命周期, 会受到所依附的 Activity 的生命周期的影响. 但是 Activity 不会受到 Fragment 的影响. Fragment 继承自 Object, 是一个独立的类, 而不是 Activity 的子类. Activity 是 Context 的子类. 和 Activity 一样, 加载时都需要调用一个生成界面的方法, Oncreate() OnCreateView() 如果不想返回 UI 界面, 可以返回 null. OnDestroyView() OnDestroy() 可以动态和静态加载一个 Fragment: 添加 layout 文件 使用 add(), remove(), replace() 等方法动态的添加, 删除, 或者替换等操作. 和 Activity 一样, Fragment 也有一个stack, 除非被销毁, 否则可以回退到上一个 fragment. Fragment 通讯两个 Fragment 不应该直接通讯因为会产生 fragment 之间的 dependency. (例如调用另一个 fragment 产生的 instance) 可以使用观察者模式的设计模式, 利用polymorphism的特性来解决这个问题. Fragment 里面定义一个 interface. 主函数继承这个 Fragment.interface, 并且override 接口. onAttach()方法中传进来的 context 就是所依赖的 Activity (的source). 把传入的 activity 的 instance 强制转换成接口类型(Fragment.interface) context. 然后就可以通过这个 reference 调用 Activity 中的其他函数, 进而调用另外一个 Fragment. Layout文件每个组件如何显示的文件. : 根据子 view 之间的依赖关系而排列, 横向纵向都会进行一次比较. : 包含的所有子 view 都是从上到下顺序排列的. 组件android 中的每一个组件都是 view 的一个子类. 组件有它自己的属性, 包括 id, layout_width, 和 layout_height 等等. 当我们生成了一个 layout 文件, 并且为这个组件设置了一个 id, 那么 R 文件中就自动为这个组建生成了一个 id, 而我们可以通过这个 id 来对组件进行操作. ListView: 生成一个 ListView 的组件 list_view.xml 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/view_id" &lt;!-- 和 java 程序联系的桥梁 --&gt; android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 改写 MainActivity里面的 onCreate(), 在程序被启动的时候直接调用这个 ListView 生成的界面. 12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //要加载到当前 Activity 界面的 layout 文件 setContentView(R.layout.list_view); //生成一个 ListView 的对象, 从载入到当前 Activity 的 layout 文件中, 通过 id 找到 ListView 的文件, 放到这个对象容器里 ListView view = (ListView) findViewById(R.id.view_id); //新建一个适配器, 并且关联数据源 ArrayAdapter adapter = new ArrayAdapter&lt;&gt;( this, R.layout.目标布局文件, R.id.目标布局文件的 id, new String[]&#123;"1", "2", "3", "4", "5"&#125;); // 容器和与容器匹配的数据都准备好了之后, assign adapter to view thisIsView.setAdapter(arrayAdapter); &#125;&#125; Adapter: 在 Java 中, Adapter 是一个interface. 用来把复杂的数据填充在界面上和用户交互. 继承了 Adapter 的其他 interface 有 ListAdapter和 SpinnerAdapter. 继承了这两个 interface 的类是 BaseAdapter(抽象类). 实际应用中 BaseAdapter 是最常用的. 而继承了 BaseAdapter 的常用的类有, SimpleAdapter, ArrayAdapter. ArrayAdapter用来绑定单一类型数据(例如集合, 数组, 列表). SimpleAdapter: 用来绑定复杂类型的数据, 只能是特定泛型的集合. 创建一个 layout 文件, list_of_items.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;ImageView android:id="@+id/image_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@mipmap/ic_launcher" /&gt; &lt;TextView android:id="@+id/text_view" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="20sp" android:textColor="@color/colorPrimary"/&gt;&lt;/LinearLayout&gt; 改写MainActivity 里面的 onCreate() 方法, 注释掉之前用 ArrayAdapter 生成的listview, 例如, 12345678910111213/** * SimpleAdapter(context, * 当前 ListView 加载的每一个 item 所对应的布局文件, * data: (List&lt;? extends Map&lt;String, ?&gt;&gt; data), * source: 布局文件 id, * from: Map 的 key * to: Map 的 value */simpleAdapter = new SimpleAdapter(this, getData(dataList), R.layout.item_of_list, new String[]&#123;"image","text"&#125;, new int[]&#123;R.id.image_view, R.id.text_view&#125;);thisIsView.setAdapter(simpleAdapter); 自定义类更加常用的形式是自定义一个Adapter 的子类. 异步加载PS: (cast) 向下转换. 1.service: 可以理解为没有 UI 的 Activity. ↩2.感谢@天放同学精准到位的总结. ღ(´･ᴗ･`)笔芯. ↩]]></content>
  </entry>
  <entry>
    <title><![CDATA[React 学习笔记]]></title>
    <url>%2F2018%2F04%2F22%2FReact-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[React, a JavaScript library for building user interfaces.1 Features Declarative: 声明式语法. 直接定义某一部分的 UI 是什么. Component-Based: 模拟 DOM, 减少与 DOM 的交互. 组件有独立的 scope. Flexible: 与已知框架可以很好的配合. 单向响应式数据, 减少重复代码. 通过 React 构建组件, 从而重复使用组件. ECMAScript6 Features let vs. var: 不同于 var, let 是 block-scoped. const: 相当于 java 中的 final. 只读不可改. Template String: 新的语法糖, 用反引号来定义一个 String, 引号内的文字结构保持不变. Srting string ${String} ${String} Object literal: 不同于ES5, 如果parameter list 的名字和 function 本身的 key 相同的话, 就可以只写 key. 例如, 123456789101112131415function getCar(make, model, price) &#123; return &#123; make: make, model: model, price: price, &#125;;&#125;function getCar2(make, model, price) &#123; return &#123; make, model, price, &#125;;&#125; 如果 key 和参数名字不同的话, 则扔需要保持 key-value-pair. 另外一个语法糖是, 可以使用 string template 直接对 key 进行操作, 例如增加一个属性 madeBy(value of make), 那么就可以直接写成 [madeBy${make}] : value. 那么生成的 key 就是自动传入make所对应的 value. 例如,这时候, 这个属性的名字就会变成madeByBMW : value. 1const car = getCar4('BMW', 'X5', 60000) 函数不再需要明确的写出 function(){ }的格式, 而可以直接在属性后面写上(){ }, 例如, depreciate: function() { } &lt;===&gt; depreciate() { }. Arrow Function: (参数) =&gt; { } 例如,2 12345678const arr = [1, 2, 3, 4];const double = arr.map(function(n) &#123; return n * 2;&#125;);const double1 = arr.map((n) =&gt; &#123; return n * 2&#125;); 它会自动绑定 this, 在它被定义的那个this. 3 可以在参数里面传默认值, 例如, 123function f(x, y=12) &#123; return x + y;&#125; 对于上面的例子, 1f(3) //15 可以传入rest parameter, 用…来表示, 例如, 12345function f(x, ...y) &#123; //剩余的 parameter 被存到一个 array 里面, 可以穿入任意长度的参数在 x 后面. return x * y.length;&#125;f(3, "hello", true) //剩余的 parameter 是长度为 2 的 array, 所以结果是6. Spread Operator (…), 使用...来分离一个集合类型, 用来 concatate 多个数组非常的灵活. 例如, 1234567const arr = [1, 2, 3, 4];const arr1 = [5, 6, 7, 8];const arr2 = [...arr, 111, 222, ...arr1]; // [1, 2, 3, 4, 111, 222, 5, 6, 7, 8]const obj1 = &#123;a: 1, b: 2&#125;;const obj2 = &#123;...obj1, c: 3&#125;;console.log(obj2); // &#123;a: 1, b: 2, c: 3&#125; 也可以当做参数传入, 1234const f = (x, y, z) =&gt; x + y + z;const arr = [1, 2, 3];console.log(f(...arr)); // 6console.log(f(...[1,2,3])) // 6 Destructuring 用来做一个一一对应的读写操作. 例如, 123456789101112131415161718192021222324let a, b, rest;[a, , b] = [1,2,3];console.log(a); // 1console.log(b); // 3[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50]// object destructuringlet &#123; a, b &#125; = &#123; a: 10, b: 20 &#125;;console.log(a); // 10console.log(b); // 20let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;console.log(z) // &#123;a: 3, b: 4&#125;// Fail-soft destructuringvar [v] = [];console.log(v); // undefined// Fail-soft destructuring with defaultsvar [v = 1] = []; console.log(v); // 1; 支持 class (支持 OOP 的语法糖) 1234567891011121314class ClassName &#123; //构造函数 constructor(name) &#123; this.name = name; &#125; //function method() &#123; console.log(this.name + 'say something.'); &#125; // 静态函数 static method() &#123; console.log('do something'); &#125;&#125; 可以继承 12345678910class SubClass extends SuperClass &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; //override speak() &#123; console.log(this.name + 'do something'); &#125;&#125; JSXJavaScript 的语法扩展, 允许在 JavaScript 里面使用 XML 语法. 用简单的语法生成 react 对象. 生成 React 对象: 可以通过 react 进行渲染的对象.直使用tag定义. 例如,1const element = &lt;h1 id="greeting"&gt;Hello, world!&lt;/h1&gt;; 生成了一个 react 的对象, 它包含了3个元素, tag 名, 属性, 和”Hello, World”, 它等价于,12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); 渲染对象1ReactDOM.render(element, document.getElementById(&apos;root&apos;)); 条件渲染和普通的 JavaScript 的使用方法一样, 可以通过 if 语句来控制渲染的组件. 例如,123456789function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125;const element1 = getGreeting();ReactDOM.render(element1, document.getElementById('root')); 更新渲染过的 react 对象4对于渲染过的组件, 如果需要更新, 则会重新渲染需要更新的组件. 例如,12345678910111213function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); 在这个例子中, 只有&lt;h2&gt;被rerender了. 这里应用了 VDOM 的概念. Virtual DOMVDOM 是一种编程概念. 是指虚拟的视图被保存在内存中，并通过诸如ReactDOM这样的库与“真实”的DOM保持同步。这个过程被称为和解。这种编程方法使用了React的声明式API：你需要告诉React你想让视图处于什么状态，React则负责确保DOM与该状态相匹配。因此你在构建你的应用时不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切5. 在创建一个 react 对象的时候可以通过提交一个包含了多个组件的 tag 来同时创建多个 react 对象. 而提交的这个 tag 就相当于一个 root node. 当根节点的任意子树发生变化的时候, react 会生成一个新的 VDOM 从而把新的状态映射到这个 VDOM 上面. 通过在原有的 VDOM 和新的 VDOM 上面运行 diffing algorithm 找到相应的节点, 对其进行重新渲染, 应用到真正的 DOM 上面, 而不会影响其他组件. 从而大大减少了对于实际 DOM 的操作. Component使用 function直接通过 JavaScript 函数来生成一个 react 的组件. 例如,12345function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; &#125;ReactDOM.render(&lt;Welcom name="Evelyn"/&gt;, document.getElementById('root')); 函数的参数传递使用 props 关键字. 在 render 的时候可以使用 JSX 语法, 在组件后面添加属性即可. 使用 class(类)创建一个 React.Component 的子类, 返回的是需要渲染的组件. props 通过直接调用的方法传递参数. 例如,123456class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render(&lt;Welcom name="Evelyn"/&gt;, document.getElementById('root')); Composing Components组件之间可以调用, 从而对于同一种 UI 效果进行不同的调用. 例如,12345678910111213141516function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name="Sara" /&gt; &lt;Welcome name="John" /&gt; &lt;Welcome name="Richard" /&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 这里面实际上应用到了 react 里面的 mounting life cycle 的概念. 在渲染(render) App 的过程中, 发现了 Welcome 组件, 对其进行传递参数以及渲染, 然后返回的这样一个过程. 从而实现了重复使用已经定义好了的 react 的对象. Props在生成组件的过程中, 不论是通过 function 还是 class 的方式, 都不能对传入的参数进行修改. 可以对参数进行任意操作, 但是不可以修改参数. 如果需要对参数进行更改, 则需要通过 setState(). State与 props 相类似, state 也是属于类的一个属性. 但是local state 是属于类的, 私有的状态. 1.https://reactjs.org/ ↩2.map 返回一个新的数组. ↩3.注意 this 的生成方式并没有发生改变, this 只有在类被初始化的时候才会产生(调用这个类的方法). ↩4.react 的对象是 immutable 的. 一旦生成无法更改. ↩5.https://doc.react-china.org/docs ↩]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈单例模式 - Singleton Pattern]]></title>
    <url>%2F2018%2F04%2F20%2F%E6%B5%85%E8%B0%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[我认为, 单例模式可以简单理解为”只生一个好”的计划生育设计模式.或者 instance 的非 0 即 1 的状态 ––– 要么没有, 有就只有一个. 其实逻辑很简单, 由类自己决定什么时候要生成一个 instance, 以及确认是否已经生成了一个实例.提供一个全局的访问点(调用构造函数的方法). 外部不能够调用构造函数 ––&gt; 构造函数私有化( private) 由内部生成一个instance ––&gt; 实现一个可以调用构造函数的方法. 类需要确认是否已经生成了一个instance ––&gt; instance == null ? create : instance; 这几个逻辑就可以实现一个简(qi)单(gai)版的单例模式的类了. 代码如下, 123456789101112131415public class Singleton &#123; private static Singleton instance; //private constructor private Singleton() &#123;/*initialization*/&#125; //static method for creating and visiting instance from outside public static Singleton getInstance() &#123; //whether instance exists if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 然鹅上面的例子不能够解决线程安全问题, 在多线程的环境内, 假设线程 A 和线程 B 同时访问这个类, 当线程 A 访问的时候实例还没有被创建, 而当线程 B 访问的时候 A 已经访问过了, 但是实例并没有被创建, 所以 B 访问的时候 instance 仍然是 null, 那么就会出现instance 重复创建的问题. 解决的方法也是简单粗暴 ––– 直接加锁, 代码如下, 123456789101112public class Singleton &#123; private static Singleton instance; private Singleton()&#123;/*initialization*/&#125; public synchronized static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 然鹅, 这种方法也有它的问题, 它并不高效. 因为只有在创建的时候才需要 mutual exclusion 来确保不会产生多个实例. 开锁解锁的过程实在麻烦. 于是, 双重锁定出现了. 1234567891011121314public class Singleton &#123; private static Singleton instance; private Singleton()&#123;/*initialization*/&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 而这个版本的双重锁定依然会产生问题, 原理其实和第一个差不多, 如果 A 在创建的过程中被 B 看到了, 那么 B 会认为instance 已经被 A 创建好了(可是有可能并没有完成初始化, 只是被分配了内存), 那么直接调用这个实例, 会导致程序崩溃. 修改的方法依然很简单 (简单的东西多半坑多….). 使用 volatile 关键字. 代码如下, 1234567891011121314public class Singleton &#123; private volatile static Singleton instance; private Singleton()&#123;/*initialization*/&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized(Singleton.class) &#123; if (instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 这样就能够确保每一个读和写的确定性了, 因为 volatile 确保了它所指向的变量的读操作一定发生在写操作的后面(writing precedes reading). 这样我们就不用让线程每次都枷锁, 而是只有在实例未被创建的时候才做加锁处理, 并且确保实例的确定性. 另一种确保线程安全的方法是, 使用静态初始化(static final). 一加载就初始化. 这样就不需要再考虑其他问题, 直接拿来用就可以了. 代码如下, 12345678910public class Singleton &#123; private static final Singleton instance = new Singleton(); private Singleton()&#123;/*initialization*/&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 而这种方法的缺陷在于, 提前占用资源. 并且, 如果在初始化的时候需要设置参数, 那么这种方法无法被应用. 因为 final 域一旦创建不能更改.最后也是最简单高效的方法应该就是枚举了. This approach is similar to the public field approach, but it is more concise, provides the serialization machinery for free, and provides and ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. … but a single-element enum type is often the best way to implement a singleton. [1] Enum 确保线程安全, 不需要担心锁的问题, 并且能够防止序列化或者反射机制导致重新创建新的对象.代码简洁的让人怀疑人生… 123public enum Singleton &#123; INSTANCE;&#125; [1]: Bloch, Joshua. Effective Java (3rd Edition): Joshua Bloch: 9780134685991 … www.bing.com/cr?IG=5B8E21E3EB364911A45C4D01A0F4314B&amp;CID=066CBDC1AC5B61F50EE1B616ADF46080&amp;rd=1&amp;h=v1tkqRWZ4_Dmqdw9V5prH4iBztvXb3p4O5mt9M6yErY&amp;v=1&amp;r=https://www.amazon.com/Effective-Java-3rd-Joshua-Bloch/dp/0134685997&amp;p=DevEx.LB.1,5081.1.]]></content>
      <tags>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 从 char 到 String]]></title>
    <url>%2F2018%2F04%2F13%2FJava%E4%BB%8E%20char%20%E5%88%B0%20String%2F</url>
    <content type="text"><![CDATA[Java 中的基本数据类型都有一个对应的wrapper class, 所有的 wrapper class 都是 IMMUTABLE 的. wrapper class 的作用是什么呢? 可以被应用到 Java generic 中, 例如 List中的 object 只能是 wrapper class. 可以定义/增加成员函数. 可以表示 null. char也有它对应的 wrapper class –&gt; Character Char在 Java 中, char 是 primitive 类型, String 则是一个类.Java 中, 一个 char (primitive type) 使用的是 Unicode, 所以是16位的(2bytes). 前 128(0~127) 个 和 ascii 码是重复的. 前 3 个和第 128 个是不可打印的( debug 时候要注意, 可以打印 int.) ‘0’ ~ ‘9’, ‘a’ ~ ‘z’, ‘A’ ~ ‘Z’是连续排列的. 所以可以通过+/-操作来得到他们的值, 或者在位置. char 常用的操作: char - ‘0’ char –&gt; int char - ‘a’ char –&gt; int(position after’a’ in the unicode chart) char - ‘A’ char –&gt; int(position after’A’ in the unicode chart) cahr - ‘a’ + ‘A’ lower –&gt; upper cahr - ‘A’ + ‘a’ upper –&gt; lower (int)char char –&gt; unicode (char)int int(unicode) –&gt; char String每一个 string 的类里面都有一个 final char[] value, int offset, 和 int count.offset 作为一个优化的存在, 多数应用于得到一个String的 substring (从下标为 index 的元素出发, 数 count 个元素). String 的构造函数: String() String(“value”) String(char[] array) String(char[] array, int offset, int count) String(StringBuilder) 当涉及到一个 string 的长度变化的时候多数建议用 StringBuilder 而不是用 Concatenation(直接加). 对于 n 个长度为 m 的数组来说, concatenate 的时间复杂度是 O(n^2 m). 因为m + m –&gt; 2m + m –&gt; 3m + m ….–&gt; nm + m = (1 + 2 + 3….+ n) m = n^2 m (每一次相加的时候都会新建一个对象).而 StringBuilder 内部实现是一个长度动态变化的 char[]. Amortized time complexity 是 O(1)的, 所以 n 个 长度为 m 的数组相加就是 O(nm).* substring 的 api: str.substring(start, end) //包含 start 不包含 end str.substring(start) //从 start 到最后 相较于 Java 7u6 来说, 新的版本直接创建了一个新的substring 的对象, 不重复使用原来的 string, 时间上更快一些. 而7u6之前的版本创建空间上重复使用了原来的 string, 创建时间更快一些, 但是使用起来的时间复杂度是 O(n). 因为 reference 指向的是原来 string 地址的起始位置. 常用的转换成 String 的方法: primitive type: value + &quot;&quot; wrapper class: String.valueOf(value) //避免 NPE String 转换成其他类型(例如 Integer): Integer.valueOf(value) Integer.parseInt(value) String 常用的一些的比较和判断的 api: boolean endsWith(&quot;suffix&quot;) boolean startsWith(&quot;prefix&quot;) int compareTo(&quot;anotherString&quot;) //lexicographical order int compareToIgnoreCase(&quot;string&quot;) boolean equals(Object) boolean equalsIgnoreCase(&quot;string&quot;) 一些其他的常用 api: boolean contains(“char sequence”) String[] split(“regex”) String[] split(“regex”, limitNumber) String trim() String toLowerCase() String toUpperCase() int indexOf(unicode#) //param 类型是 int, 这里面通常直接使用一个 char, 只是自动进行了一个类型转换. int lastIndexOf(‘char’)etc. StringBuilder 的常用 api:2 append(‘char’) //O(1) append(“String”) //O(n) 这里面, 返回类型是 String 的方法都不是 inplace 的操作, 因为 String 是 immutable 的类型. 所以时间复杂度都是 O(n)的, 因为要重新创建一个对象1. Parse a String into Integer (乞丐版 atoi)input: A String with only positive numbers.output: The position integer, which the string represents. 最基本的 char –&gt; int 的应用. 代码如下: 1234567891011public int parsInt(String str) &#123; if (str == null || str.length() == 0) &#123; throw new IllegalArgumentException("Invalid input."); &#125; int result = 0; for (char ch : str.toCharArray()) &#123; result = result * 10 + (ch - '0'); &#125; return result;&#125; Atoiinput: A String with all characters that can make a valid integer.output: The integer. Corner cases: Null/Empty input Leading space Signs(+ / -) Overflow 其实和就是多了一些 corner case. 可以先把基础代码写进去, 然后逐渐添加解决方案. 代码如下: 123456789101112131415161718192021222324252627282930public int parsInt(String str) &#123; if (str == null || str.length() == 0) &#123; throw new IllegalArgumentException("Invalid input."); //null/empty input &#125; str = str.trim(); //leading/trailing space boolean positive = true; //sign. int i = 0; while (i &lt; str.length()) &#123; if (str.charAt(i) == '-' || str.charAt(i) == '+') &#123; positive = str.charAt(i) == '+'; i++; //If it has a sign, whether it's '-' or '+', index needs to move rightward. &#125; &#125; //int result = 0; long result = 0; //overflow for (; i &lt; input.length; i++) &#123; result = result * 10 + (ch - '0'); if (result &gt; (long)Integer.MAX_VALUE + 1) &#123; //MAX_VALUE + 1 = abs(MIN_VALUE); break; &#125; &#125; result = positive ? result : result * -1; //adding sign if (result &gt; (long)Integer.MAX_VALUE) return Integer.MAX_VALUE; if (result &lt; (long)Integer.MIN_VALUE) return Integer.MIN_VALUE; return (int) result;&#125; Valid Numericinput: A string.output: Whether the string is a valid numeric. Corner cases: Null/empty input Leading/trailing space Leading 0s Decimal point Sign -/+ Scientific notation (e/E) 1234567891011121314public boolean isValid(String str) &#123; if (str == null || str.length() == 0) &#123; return false; &#125; String pattern = "[-+]?(([0-9]+(\.[0-9]*)?)|\.[0-9]+)([eE][-+]?[0-9]+)?" ; Pattern re = Pattern.compile(pattern); Matcher m = r.matcher(str); if (m.find())&#123; return true; &#125; return false;&#125; Char Removalinput: A string and target(s) that needs to be removed.output: A stirng after remove certain characters. 可以使用 char array, 两个指针i, j从左往右扫描, i的左边不包括 i 都是要保留的, 最后返回 new String(input, 0, i). 或者使用一个 StringBuilder, 一个指针, 如果是需要保留的元素就加到 StringBuilder 里面, 否则跳过. 需要一个额外的数据结构 HashSet 为了可以快速的确认是否是需要被删除的 target. 代码如下: 1234567891011121314151617181920public String removeChar(String str, List&lt;Character&gt; tagert) &#123; if (str == null || str.length == 0 || target.size() == 0) &#123; return str; &#125; Set&lt;Character&gt; candidates = new HashSet&lt;&gt;(); for (Character s : target) &#123; candidates.add(s); &#125; char[] set = str.toCharArray(); int i = j = 0; while (j &lt; set.length) &#123; if (!candidates.congtains(set[j])) &#123; set[i++] = set[j++]; &#125; else &#123; j++; &#125; &#125; return new String(set, 0, i);&#125; Space Removalinput: A string.output: A string with no leading nor trailing spaces, and leave one space between words. 和 char removal 是一样的, 只是 target 变成了 space. 删除所有的 space 之后, 在不同的单词中间加上一个空格. 这里只需要关注指针 j 的3种状态, j == “ “, j != “ “ (j 指向的是单词的首字母, j 指向的是单词的非首字母). Cases: String with only spaces Leading spaces and trailing spaces 代码如下:123456789101112public String removeSpace(String str) &#123; if (str == null || str.length == 0) &#123; return str; &#125; char[] set = str.toCharArray(); int i = 0, j = 0; while (j &lt; set.length) &#123; if (j == " ") &#123; j++ &#125; &#125;&#125; Left Padinput: a string, output size, (and a char).output: new string with size of length fulfill by char/space. 实现一个leftpad库. 包含了两种重载的方法. 有替补字符. 无替补字符, 则用空格代替. 这是一道随机抽出来的简单题, 还挺好玩儿的. 直接po 一下代码吧.时间复杂度 O(n), n 是 size. 空间是 O(1).123456789101112131415161718192021222324252627public class LeftPad &#123; /** * @param originalStr: the string we want to append to with spaces * @param size: the target length of the string * @return: A string */ public String leftPad(String originalStr, int size) &#123; return leftPad(originalStr, size, ' '); &#125; /** * @param originalStr: the string we want to append to * @param size: the target length of the string * @param padChar: the character to pad to the left side of the string * @return: A string */ public String leftPad(String originalStr, int size, char padChar) &#123; if (originalStr == null) &#123; return null; &#125; StringBuilder bd = new StringBuilder(); for (int i = 0; i &lt; size - originalStr.length(); i++) &#123; bd.append(padChar); &#125; return new String(bd + originalStr); &#125;&#125; Palindrome Permutation I (LeetCode 266)input: a stringoutput: whehter there exists a palindrome permutation. 本来以为是一道排列组合题, 但是要求返回的是 true or false. 联想一下 palindrome 的特性, 相同的字母数量一定是偶数的. 可以有唯一一个单独的存在. 那么其实就可以用打擂台的方式, 用一个 set 就可以了, 反正出现一个相同的就会删除一个. 时间复杂度是 O(n), 空间复杂度是 O(n).123456789101112131415161718192021222324public class CanPermutePalindrome &#123; /** * @param s: the given string * @return: if a permutation of the string could form a palindrome */ public boolean canPermutePalindrome(String s) &#123; if (s == null) &#123; return true; &#125; //字母和出现的次数 Set&lt;Character&gt; map = new HashSet&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (map.contains(ch)) &#123; map.remove(ch); &#125; else &#123; map.add(ch); &#125; &#125; return map.size() &gt; 1 ? false : true; &#125;&#125; Palindrome Permutation II (LeetCode 267)input: a string.output: return all possible palindrome permutations without duplicates. 虽然这两道题是兄弟吧, 但是差距有点大. 非要搭上点儿联系的话, palindrome permutation I 可以看做是一个预处理. 那么首先要花费 O(n)的时间来判断一下给定的 string 是否能够构成 palindrome. 其次就要O(n!)的时间深搜找排列了. 第一步的空间复杂度是 O(n), 因为搜索的过程中可能会把全部元素都存放在 set 里面. 第二步的空间复杂度是 O(n/2 + n/2),只考虑一半元素的全排列, 所以还是 O(n). 根据回文的定义, 中心点左右两边的元素是对称的, 所以这里需要考虑两个因素, 中心元素 对称元素可以像 Left Pad 那道题一样, 如果有中心元素, 则传入中心元素, 否则传入String (方便直接做 concatenation). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class PalindromePermutationII &#123; /** * @param s: the given string * @return: all the palindromic permutations (without duplicates) of it */ public List&lt;String&gt; generatePalindromes(String s) &#123; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (s == null) &#123; return result; &#125; //用来判断是否可以成为 palindrome, 以及最后剩余的中心元素是什么 Set&lt;Character&gt; map = new HashSet&lt;&gt;(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (map.contains(ch)) &#123; map.remove(ch); list.add(ch); &#125; else &#123; map.add(ch); &#125; &#125; if (map.size() &gt; 1) &#123; return result; &#125; String mid = ""; for (char c : map) &#123; mid = c + ""; &#125; //如果 input 已经排好序, 那么就不需要排序了. Collections.sort(list); helper(list, 0, new StringBuilder(), result, mid, new boolean[list.size()]); return result; &#125; private void helper(List&lt;Character&gt; list, int index, StringBuilder bd, List&lt;String&gt; result, String mid, boolean[] visited) &#123; if (bd.length() == list.size()) &#123; result.add(new String (bd + mid + bd.reverse().toString())); bd.reverse();/////////////这里一定要记得翻转回来, 否则返回上一层的结果是反转过的 string return; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; if (visited[i]) &#123; continue; &#125; if (i != 0 &amp;&amp; list.get(i) == list.get(i - 1) &amp;&amp; !visited[i - 1]) &#123; continue; &#125; bd.append(list.get(i)); visited[i] = true; helper(list, i + 1, bd, result, mid, visited); bd.deleteCharAt(bd.length() - 1); visited[i] = false; &#125; &#125;&#125; Java 有一些 cache/pooling 上的优化(尽量减少在 heap 上创建对象), 例如 Integer object -128 ~ 127, 两个相同的 String 等等1. 所以在比较两个 Object 的值是否相等的时候, 尽量不要用 ==, 而用 .equals== 如果两边都是 reference, 那么(没有优化的情况下)会比较地址. 如果有一边是 primitive type, 那么就会进行 unboxing/autoboxing.而+ - * / &lt; &gt; &lt;= &gt;= 则不需要担心, 因为在 Java 中它们只能够被应用在 primitive type 上面, 所以会被自动的 unboxing/autoboxing. 1.对于 String 来说, 因为它是 immutable 的, 即使做了一个在 cache 上的优化(两个值相同的 varibale 指向了同一个地址), 也不会影响结果. 因为 String 是 immutable 的, 如果对其中一个 varibale 进行了更改(增删操作), 那么系统会重新创建一个对象并且使变量指向这个新的对象的地址. ↩2.StringBuilder 和 StringBuffer 最主要的区别就是线程安全, 单线程中不需要 StringBuffer. ↩]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS 从入门到放弃 IV]]></title>
    <url>%2F2018%2F04%2F13%2FDFS%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20IV%2F</url>
    <content type="text"><![CDATA[“晚上吃啥?” “随便.” “不行.” “为啥?” “死循环了, 没有退出条件.” N Queeninput: a integer n.output: return all distinct solutions to the n-queens puzzle. The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Using dfs to try row by row to see which column is valid. If valid, go to next row, otherwise, continue. The index of the list represents the row, and the valud of the index is the number of column it can be put. Fom the top to current row, if column has a queen, or the absolute value between columns and rows are the same, then it is not a valid position. The time complexity is O(n!), the space complexity is O(n). A little bit different from LeetCode 51.1234567891011121314151617181920212223242526272829303132333435363738public class NQueen &#123; /** * @param n * @return */ public List&lt;List&lt;Integer&gt;&gt; findNQueen (int n) &#123; if (n &lt;= 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); helper(n, new ArrayList&lt;&gt;(), result); return result; &#125; private void helper(int input, List&lt;Integer&gt; subSol, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (subSol.size() == input) &#123; result.add(new ArrayList&lt;&gt;(subSol)); return; &#125; for (int i = 0; i &lt; input; i++) &#123; if (isValid(i, subSol)) &#123; subSol.add(i); helper(input, subSol, result); subSol.remove(subSol.size() - 1); &#125; &#125; &#125; private boolean isValid(int column, List&lt;Integer&gt; subSol) &#123; for (int i = 0; i &lt; subSol.size(); i++) &#123; if (subSol.get(i) == column || subSol.size() - i == Math.abs(column - subSol.get(i))) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS 从入门到放弃 III]]></title>
    <url>%2F2018%2F04%2F10%2FDFS%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20III%2F</url>
    <content type="text"><![CDATA[DFS 的特点是, 从哪儿来的状态回到哪儿去(Back Tracking).DFS 的思路是, 执行多少层, 每层都有什么状态. 与 subset 的类型不太相同的是, subset 通常从”空”出发, 在每一个节点选择是否要选择某个元素, 以及是否继续向下(后)搜索.排列的问题每一个元素都要参与到结果当中, 而顺序决定结果. 可以从”空”出发, 那么只有最后一层的结果是有效的; 也可以从”满”出发, 每一个不相同的排列顺序都是有效的. 原理都是相同的 ––– 每一个元素都要出现在每一个位置上. Permutationinput: A linear data structure like an array, a string, etc. No duplicated element.output: A list of lists of all permutations. 对于每一个元素来说, 它要尝试每一个位置. 或者说对于每一个位置来说, 它有 n 种选择. 在第 i 层的时候, 有 n - i 个选择. 需要注意的是, 这里 for 循环是用来控制层数而不是状态的.For each position i, it has at most (n - i) - i choices, where i represents the level of the node. Therefore, the time complexity would be O(n!).This case chooses to use a boolean array to indicate the elements that has appeared in the subsolution. This costs O(n). And the depth of the recursive call would be n, so the call stack would take O(n). Thus, the space would be O(2n) ==&gt; O(n). 代码如下:1234567891011121314151617181920212223242526272829303132public class Permutation &#123; public List&lt;List&lt;Integer&gt;&gt; permutation(int[] input) &#123; if (input == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(input, new HashSet&lt;&gt;(), new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int[] input, Set&lt;Integer&gt; occ, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (sub.size() == input.length) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = 0; i &lt; input.length; i++) &#123; if (occ.contains(input[i])) &#123; continue; &#125; sub.add(input[i]); occ[i] = true; dfs(input, occ, sub, result); sub.remove(sub.size() - 1); occ[i] = false; &#125; &#125;&#125; 这道题可以不需要额外的数组来判断当前层的元素. 依然只关注 dfs, 不考虑优化, 笔芯❤~ Permutation IIinput: A linear data structure like an array, a string, etc. With DUPLICATED elements.output: A list of lists of all UNIQUE permutations. 有重复元素, 如何去重? 其实和 SubsetII 有重复元素是一样的道理(排序的判断条件可能会有些不同). 在每一个节点都需要判断一下这个元素是不是当前层的第一个被使用的元素, 所以每一个层都需要一个 HashSet. 如果当前层已经使用过这个元素了, 那么后续就不考虑了. At each position i, it has n - i times choices, as same as the regular permutation.A HashSet is used to deduplicate. At each level i, at most n - i space would be taken to save visited element. Space complexity would be n + (n - 1) + (n - 2) + (n - 3) + …. + 2 + 1 = O (n^2). 代码如下:1234567891011121314151617181920212223242526272829303132333435```javapublic class Permutation &#123; public List&lt;List&lt;Integer&gt;&gt; permutation(int[] input) &#123; if (input == null) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); //dfs(input, new HashSet&lt;&gt;(), new ArrayList&lt;&gt;(), result); dfs(input, new ArrayList&lt;&gt;(), result) return result; &#125; private void dfs(int[] input, /*Set&lt;Integer&gt; occ,*/ List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (sub.size() == input.length) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; Set&lt;Integer&gt; occ = new HashSet&lt;&gt;(); for (int i = 0; i &lt; input.length; i++) &#123; if (occ.contains(input[i])) &#123; continue; &#125; sub.add(input[i]); occ[i] = true; dfs(input, occ, sub, result); sub.remove(sub.size() - 1); occ[i] = false; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS 从入门到放弃 II]]></title>
    <url>%2F2018%2F04%2F08%2FDFS%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20II%2F</url>
    <content type="text"><![CDATA[专注 dfs 20年, 粗略的说一说基于 subset 的🌰. Partition an Array into K Equal Sum Subsetsinput: An array, and int number k.output: Boolean whether the array can be divided into k subsets with equal sum. 是否能被等分? 如果k 能够被数组的总和整除, 则有可能存在这样 k 个子集. 找到 k 个总和等于 sum/k 的子集. 可以使用子集求和的方法, 或者找到所有满足条件的子集的路径. 每个元素只能用一次, 所以需要一个额外的数据结构来记录是否使用过.It could be nicer if srot the array in descending order It runs k times looking for a qualified subset, so the worst case would be the most O(k n! n), where n! is for seaching String Splitinput: String /char array/etc.output: List&lt;List&gt; /List/ etc. 给一个string(直接用 substring)或者 char array( 可以用 StringBuilder), 把它进行切分, 每一个被切分过的 string 长度不能超过2. 举个🌰, “abcd”, 返回的结果是, [[a, b, c, d], [a, b, cd], [a, bc, d], [ab, c, d], [ab, cd]].PS: 每一个 subset 都是有双引号的, 略… 每一个元素只和它后一个元素有关系. 每一个分支的状态是它自己或者它和后面一个元素. 后面一个元素被选过了之后失去进入下一轮的资格. The number of element in the input is n. Every element can have at most two branches at each level. Therefore, the time complexity is O(2^n);The height of the tree would be n as well; thus the space would be the call stack which is O(n); 代码如下 1234567891011121314151617181920212223242526272829303132333435public class SplitString&#123; public List&lt;List&lt;String&gt;&gt; splitString(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); if (s == null) &#123; return new ArrayList&lt;&gt;(); &#125; if (s.length() == 0) &#123; result.add(new ArrayList&lt;&gt;()); return result; &#125; dfs(s, 0, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(String input, int index, List&lt;String&gt;sub, List&lt;List&lt;String&gt;&gt; result) &#123; if (index == input.length()) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; sub.add(input.substring(index, index + 1)); dfs(input, index + 1, sub, result); sub.remove(sub.size() - 1); if (index + 1 &lt; input.length()) &#123; sub.add(input.substring(index, index + 2)); dfs(input, index + 2, sub, result); sub.remove(sub.size() - 1); &#125; &#125;&#125; 当然这道题应该有更优化的写法, 这里只考虑 dfs. Valid Permutation of Parenthesesinput: An int n represents the pair of parentheses.output: A list of string with all valid permutation of given number pair of parentheses. 在每一个位置上, 只有2个选择, 左括号还是右括号. 放置左右括号的前提条件是什么? 如果当前已经有了n个左括号, 那么就不能再添加左括号. 如果当前左括号小于等于右括号的数量, 那么就不能再添加右括号了. 举个🌰, input = 3, output = [&quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;]At every position, it has two choices, adding left or right parenthese. It has 2 * n positions. Therefore, time compexity is O(2^2n).The recursive call would have at most 2n frames. Therefore, the space complexity is O(2n). 代码如下:123456789101112131415161718192021222324252627282930public class ValidParentheses&#123; public List&lt;String&gt; validPren (int n) &#123; if (n &lt;= 0) return new ArrayList&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); dfs(n, 0, 0, new StringBuilder(), result); return result; &#125; private void dfs(int left, int right, StringBuilder bd, List&lt;String&gt; result) &#123; //monitor the number of right parentheses, //then compare the number of left and right if (right &gt;= size) &#123; result.add(new String(bd)); return; &#125; if (left &lt; right) &#123; bd.append("("); dfs(left + 1, right, bd, result); bd.deleteCharAt(bd.length() - 1); &#125; if (right &lt; left) &#123; bd.append(")"); dfs(left, right + 1, bd, result); bd.deleteCharAt(bd.length() - 1; &#125; &#125;&#125; K Sum IIinput: An int array with UNIQUE numbers, k elements that can sum up the target, and a target number.output: List of lists of k intergers that sum up the target. 暴力求解, 基本不考虑优化. 给定数组中的元素是没有重复的, 所以连 set 也不需要了, 只要保证每次只看 index 后面的元素就可以了. 限定条件, 每一个结果里面只能有 k 个元素. 举个🌰, [1, 2, 3, 4], k = 2, target = 5. 返回值为, [[1, 4][2, 3]], 也就是说, 从每一个 index 出发, 希望它每一次只和它后面的另外一个数字相加, 如果结果与 target 相等, 并且结果里面只有2个元素, 那么就返回这个结果.At each level, i represents the number of i-permutations of n, where i is restricted by k. Therefore, at the each level, it’s looking for C(n, 1), C(n, 2), …, C(n, k). To add them up, 1 + C(n, 1) + … + C(n, k) = (1 + 1)^k = 2^k. If k is equal to the length of input. Then the time complexity is O(2^n).Since we only consider answer with number of k elements, the frame of the call stack would be k, tops. So it’s O(k).代码如下: 123456789101112131415161718192021222324252627282930313233public class KSum &#123; public List&lt;List&lt;Integer&gt;&gt; kSum(int[] A, int k, int targer) &#123; if (A == null || A.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(A, 0, targer, k, new ArrayList&lt;Integer&gt;(), result); return result; &#125; private void dfs(int[] input, int index, int target, int k, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; //可以在这里返回, 也可以在 for 循环里面控制,具体参见 DFS I // if (target &lt; 0 || k &lt; 0) &#123; // return; // &#125; //为了避免元素等于 target 的情况, subSolution 里面只有1个元素 if (target == 0 &amp;&amp; k == 0) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = index; i &lt; input.length &amp;&amp; k &gt; 0; i++) &#123; if (target - input[i] &gt;= 0) &#123; sub.add(input[i]); dfs(input, i + 1, target - input[i], k - 1, sub, result); sub.remove(sub.size() - 1); &#125; &#125; &#125; &#125; Combination Sum IIinput: An unordered int array with DUPLICATED elements, and a target number.output: All UNIQUE combinations in the array which are candidate numbers sum to the target. 依然暴力求解, 即使考虑优化也要考虑重复元素的问题. 首先, 返回结果必须是 unique 的. 其次, 每一个元素都只能使用一次. 那么就要解决重复元素能不能被重复选择的问题[笑]. 和 subsets II 的解法一样. 先排个序, 反正 dfs 的时间复杂度已经是指数级的了, 排个序无伤大雅. 排序首先确保了结果的有序性, 有助于辨别是否重复, 其次可以选择 HashSet 或者 index 两种方法去重. At each subsolution position i, it runs n - i times looking for candidate. There are n possible positions, where n is the length of input. Therefore, the time complexity is O(n!).Space complexity is O(n) for call stack and using index to deduplicate (without HashSet in each level). 123456789101112131415161718192021222324252627282930313233public CombSum &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] num, int target) &#123; if (num == null || num.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; Arrays.sort(num); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(num, 0, target, new ArrayList&lt;&gt;(), result); return result;&#125; private void dfs(int[] input, int index, int target, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (target == 0) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; //Set&lt;Integer&gt; occ = new HashSet&lt;&gt;(); for (int i = index; i &lt; input.length; i++) &#123; //if (target - input[i] &gt;= 0 &amp;&amp; occ.add(input[i]))&#123; if (target - input[i] &gt;= 0 &amp;&amp; (i == index || input[i - 1] != input[i])) &#123; sub.add(input[i]); dfs(input, i + 1, target - input[i], sub, result); sub.remove(sub.size() - 1); &#125; &#125; &#125;&#125; Combination of Coinsinput: A target value and a list of the value of each coins.output: A List of lists of candidates of number of each coins that can add up to the target. 每一层的状态取决于当前层的 target 大小. 所以需要一个动态的变量来判断分支数量. 我们希望把层数控制在 coin 的数量而不是 target 的大小, 因为如果 coin 的面值包含1的话, 那么层数就是target 的大小, 如果 target 很大, 就会爆栈. At each node of the recursion tree, it has current target / valueOfCoin states. Overall, the one has the most branches is the coin that has smallest value. The states of the node is whatever the factor is. Suppose that factor is k and the number of coin is n. The time complexity is k^n.Space is the number of coins. 代码如下:123456789101112131415161718192021222324252627public class CombCoin&#123; public List&lt;List&lt;Integer&gt;&gt; findCoins(int n, int[] coins) &#123; if (n &lt;= 0) &#123; throw new IllegalArgumentException("Invalid input"); &#125; if (coins == null || coins.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(n, 0, coins, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int moneyLeft, int level, int[] coins, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (level == coins.length) &#123; if (moneyLeft == 0) result.add(new ArrayList&lt;&gt;(sub); return; &#125; int factor = moneyLeft / coins[level]; for (int i = 0; i &lt;= factor; i++) &#123; //add 0 ~ factor number of coins sub.add(i); dfs(moneyLeft - coins[level] * i, level + 1, coins, sub, result); sub.remove(sub.size() - 1); &#125; &#125;&#125; Cartesian Productinput: A 2D array with different length of column in each row.output: List of lists of Catesian product such that A×BxC = {(x,y,z)|x∈A ∧ y∈B ∧ z∈C}; 从每一行的第0列开始遍历, 直到最后一行, index == input.length; 每一个行的元素长度有可能不一致, 考虑越界问题. 这里面 for loop 不再是控制层数而是控制每一层的分支, 所以需要退出条件. 举个🌰, 给定一个二维数组[[1, 2, 3],[4, 5],[6, 7, 8]], 它的层数和 row 相关, 分支最多不超过column 的最大值. Suppose the matrix has n rows and m columns. It has at most n levels, and at each level, a node has at most m branches. Thus time complexity is O(m^n);No extra space is used besides the call stack, which is the number of row, O(n). 代码如下:123456789101112131415161718192021222324252627public class CarteProduct &#123; public List&lt;List&lt;Integer&gt;&gt; getSet(int[][] input) &#123; if (setList == null || setList.length == 0) &#123; return new ArrayList&lt;&gt;(); &#125; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(input, 0, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int[][] input, int row, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (row == input.length) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = 0; i &lt; input[row].length; i++) &#123; sub.add(input[row][i]); dfs(input, row + 1, sub, result); sub.remove(sub.size() - 1); &#125; &#125;&#125; All Factors Of A Numberinput: An int.output: A list of list of all candidates that the production is given number. 从2开始找到 input 的完全平方根的整数为止. 需要注意的是, 什么时候继续向下除, 什么时候停止. 和前面找 sum 的题差不多, 只是需要注意一下乘除法的细节. For each number at a level, it has sqrt(n) choices to run (although situations are optimized in the code). The recursive call has the most sqrt(n) times. The time complexity is O(sqrt(n) ^ sqrt(n)). LOGN^FACTORSapces is the call stack which is sqrt of n. 代码如下:123456789101112131415161718192021222324252627public class AllFactors&#123; public List&lt;List&lt;Integer&gt;&gt; factors(int n) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); dfs(2, n, new ArrayList&lt;&gt;(), result); return result; &#125; private void dfs(int startPoint, int quotient, ArrayList&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (quotient &lt;= 1) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; for (int i = startPoint; i &lt;= quotient; i++) &#123; //corner case: n = 2 int curFactor = i * i &lt;= quotient ? i : quotient; //划重点 if (quotient % curFactor == 0) &#123; sub.add(curFactor); dfs(curFactor, quotient / curFactor, sub, result); sub.remove(sub.size() - 1); &#125; if(i * i &gt; quotient) break; &#125; &#125;&#125; 感谢@景阳同学的友情支持~笔芯❤]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS 从入门到放弃I]]></title>
    <url>%2F2018%2F04%2F06%2FDFS%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%20I%2F</url>
    <content type="text"><![CDATA[Depth First Search 是一种基于树状(Tree) 或者图状(graph)的搜索算法, 本质是从一个节点(root)出发, 向每一个分支进行搜索, 而对于每一个分支来说, 它本身就是一个节点, 从这个节点继续向它可能产生的分支进行搜索, 最终在搜索所有的可能性的过程中找到结果. 也就是所谓的普遍撒网吧. SubsetI SubsetII Partition an Array into K Equal sum subsets Combination of K I Combination of K II Combination of Coins Combination of Factors PermutationI PermutationII Valid ParenthesesI Valid ParenthesesII N-QueenI N-QueenII Subset Iinput: A linear data structure, such as an array or a string.output: A list of lists of all unique subsets. DFS 的核心就是回溯( backtracking), 也就是说, 这些分支从哪里来的, 最后清除了沿途附加的状态再回到哪里去. dfs 可以使用 for 循环来控制 recursion 的层数. 在这里, for 循环的终止条件就是 dfs 的终止条件. 局部变量 i 作为参数 index 传入函数 dfs, 当 i 等于 input 的长度的时候, 函数返回. 其实和普通的 for loop 是一样的, 只要明白 index 和 i 分别表示的是什么. 这里在最外层的for loop 执行了 n 次, n 是 input 的长度, 而每一次调用的时候 i 进行了一次 + 1的操作, i 次调用的dfs 中的 for loop 会执行 (n - i) - i 次, 同样的, 当 i 的长度等于 input 的长度的时候函数返回, 一次退回上一层调用它的那个循环中, 再继续. For a position i in the input, it has (n - i) - i (where n - i is the size of sub-problem, f(n - 1))choices to run, where n is the length of the input. Every time when the dfs is being called, the size of the problem reduces to n - i, therefore T(n) = 2T(n - 1), O(2^n).Since it’s recursion, the call stack would be the length of the input, which is O(n). 代码如下:123456789101112131415161718192021222324252627282930class Subsets &#123; public List&lt;List&lt;Integer&gt;&gt; findSubsets(int[] input) &#123; if (input == null) &#123; return new ArrayList&lt;&gt;(); &#125; if (nums.length == 0) &#123; results.add(new ArrayList&lt;Integer&gt;()); return results; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); dfs(input, 0, new ArrayList&lt;&gt;()); return res; &#125; private void dfs(int[] input, int index, ist&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result)&#123; result.add(new ArrayList&lt;Integer&gt;(subSolution)); for (int i = index; i &lt; input.length; i++) &#123; subSolution.add(input[i]); dfs(input, i + 1, result); subSolution.remove(sobSolution.size() - 1); &#125; &#125;&#125; 首先如果不是用 for 循环来控制 recursion 的层数, 那么 recursion 就一定需要一个退出条件. 也可以使用 for loop 来每一层的状态, 或者说每一个位置上的可能性, 或者每一个元素可能产生的分支个数等等. 那么 dfs 的终止条件就不再是 for 循环的终止条件了, 而需要明确的写出来. 通常是当下标指向了input 长度 + 1的位置的时候. 那么局部变量 i 表示的就是对于当前下标来说, 它有几种选择, 只是 i 不再代表可选择元素的下标了. 所以参数需要使用 index. for loop 的意义是在以当前 index 为节点调用2次 dfs, 如果 i 是0的话, 加上 index 对应的元素, i = 1时返回上一层的状态, 并且进行下一次的递归调用 (也就是不加的情况). For element in a position i, it has two states, eighter added or removed. The it has n positions, where n is the length of the input. Thus, time complexity is 2^n.Space complexity is the call stack layers, which is O(n). 代码如下, 123456789101112131415161718private void dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (index == input.length) &#123; result.add(new ArrayList&lt;&gt;(subSolution); return; &#125; for (int i = 0; i &lt;= 1; i++) &#123; if (i == 0) &#123; subSolution.add(input[index]); &#125; else &#123; subSolution.remove(subSolution.size() - 1); &#125; dfs(input, index + 1 , result); &#125;&#125; 因为只有2种状态, 所以其实不需要一个 for 循环. 123456789101112131415private void dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (index == input.length) &#123; result.add(new ArrayList&lt;&gt;(sobSolution)) &#125; subSolution.add(input[index]); dfs(input, index + 1, subSolution, result); subSolution.remove(sobSolution.size() - 1); dfs(input, index + 1, subSolution, result);&#125; Subset II有重复元素怎么办?通常有两种解决方案, 排序 HashSet/HashMap(根据具体要求) 因为 dfs 的时间复杂度一定是高于排序的, 所以在时间复杂度上面没有区别. 空间复杂度来说, 如果是一个 array, 那么排序的空间复杂度就是 call stack 的层数, 如果是一个 String, 那么排序就一定要把 String 转换成 array 之后再排序. 所以就具体情况具体分析吧. 排序的方法 这里就用到了 Subset I 里面对于 index 和 i 的物理意义的分析, 当 i == index 的时候是在当前层第一次进入 for loop 的情况, 之后在调用dfs 的时候, 把 i 所在元素的后一个元素当做 index 参数传给 dfs. 所以当函数返回之后, local 变量被 GC, i 依然是作为 for loop 的自增变量存在. 所以对于一个排序的数组来说, 只有在当前层 for loop 第一次循环的时候 i 和 index 指向的是同一个元素. 那么当 index 和 i 不是指向同一个元素的时候( i 自增循环), 如果 index 和 i 下标指向的元素依然相同, 就说明是重复元素, 那么久可以直接跳过(不选的情况). 简而言之, 只有满足某种条件才从当前节点出发, 调用 dfs. 代码如下: 12345678910111213141516public dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(subSolution)); for (int i = index; i &lt; input.length; i++) &#123; if (i != index &amp;&amp; input[i] != input[i - 1]) &#123; ///i != index 保证了不会越界, 即使 index == 0 的情况. subSolution.add(input[i]); dfs(input, i + 1, subSolution, result); subSolution.remove(subSolution.size() - 1); &#125; &#125;&#125; 如果不使用 for 循环作为递归调用的终止条件判断, 基于对每一层传入参数 index 的选取, 它的树状结构应该是这样的. 可以看到, 以一个重复元素为节点展开的递归调用所产生的 subset 是和它第一次出现的节点的 subset 完全一致. 那么在当前层判断 index 是否第一次出现, 如果是, 那么就跳过. 代码如下:12345678910111213141516171819public dfs(int[] input, int index, List&lt;Integer&gt; sub, List&lt;List&lt;Integer&gt;&gt; result) &#123; if (index == input.length()) &#123; result.add(new ArrayList&lt;&gt;(sub)); return; &#125; sub.add(input[index]); dfs(input, index + 1, sub, result); sub.remove(sub.size() - 1); while (index + 1 &lt; input.length &amp;&amp; input[index] == input[index + 1]) &#123; index++; &#125; dfs(input, index + 1, sub, result);&#125; HashSet 的方法 假设重复元素只保留一个, 那么自然的想到可以把使用过的元素放到 HashSet 里面. 需要注意的是, 当我们返回上一层的时候, 有可能还会用到之前取过的元素, 那么这个 HashSet 就只能作用在当前层. 也就是说, 当index 作为 node 传入的时候, 没进入一次 for loop 就会形成一个新的 HashSet, 当函数返回的时候, 所有当前层存在 set 里面的元素都不会被执行. At each level, it runs n - i times looking for candidates, so the time comlexity would be as same as the regular subset.However, if use a Hashset at each level to save visited elements, it would cost O(n^2) space.代码如下: 1234567891011121314151617public dfs(int[] input, int index, List&lt;Integer&gt; subSolution, List&lt;List&lt;Integer&gt;&gt; result) &#123; result.add(new ArrayList&lt;&gt;(subSolution)); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = index; i &lt; input.length; i++) &#123; if (set.add(input[i])) &#123; subSolution.add(input[i]); dfs(input, i + 1, subSolution, result); subSolution.remove(subSolution.size() - 1); &#125; &#125;&#125; Subsets 的解法有很多种, 最直观的是深度优先搜索(DFS), 另外也可以使用宽度优先搜索(BFS), 根据其特性, 对于每一个元素 e 来说都有0 或者1两个状态还可以使用bit operation, 或者直接使用多层 for 循环, 每一层控制2个选择, 加元素与不加元素.针对每一种dfs 还可以有一些小小的 optimization. 暂且不表. 专注是优良品质, 这里就只写 dfs 了. 笔芯~❤]]></content>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Application背后的那些事儿]]></title>
    <url>%2F2018%2F04%2F06%2FWeb-Application%E8%83%8C%E5%90%8E%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[当你在地址栏中输入” www.google.com&quot; 之后发生了什么? 首先浏览器会识别 URL 地址: 包括协议( http/https/ftp), 域名google.com, 以及它对应的端口号. http 默认端口号为80, https 端口号为443, ftp 端口号为21. 浏览器会现在各种 cache ( browser cache, OS cache, DNS cache, etc)中查找, 如果都找不到就把任务丢给 ISP’s DNS (Internet Service Provider). ISP 作为服务供应商, 积极本着积极响应客户需求的原则从高到低, 从远到近的进行递归搜索. 直到找到这个地址所在的所有服务器, 返回最近的, 效果最好的那个地址给浏览器. 浏览器就就可以骚骚的拿着这个地址向服务器发送请求( get, post, etc). 服务器会返回给浏览器一个确切的地址. 现在浏览器确认这个地址是有效的了, 然后不要脸的又发送了一次一模一样的请求. 这一次 server 会派 handler 来处理这个请求, 读取它的参数, (以及更新服务器端的内容). handler 结束工作之后会生成一个 HTML 的回复, 然后服务器会把这个回复交给浏览器. (HTTP/1.1 200 OK) 浏览器收到这个回复之后就会可视化这个 HTML 的内容, 并且向服务器发送读取内容的请求并接收这些文件. (Images, CSS, JS files, etc) 所谓协议是为了让双方通讯可以理解, 这里通常我们会使用 HTTP 协议. 为了确保和目标进程链接正确, 使用 TCP 协议. IP 地址是为了保证请求能发送到正确的机器上. 对一个 Web Application 来说, 它的职能范围就是在客户端和服务器端收到请求之后,能够正确处理. 关于 Tomcat就是一个用来处理各种 Web Application 基本操作的框架. 例如如何接受 HTTP 的请求, 如何发送 HTTP 的结果, 如何调用与 HTTP 请求相关的进程, 如何建立 TCP 的链接, 以及建立连接后如何把 HTTP 请求的处理结果返回给客户端. 它可以运行在本地或者远程服务器上.作为开发人员只需要处理接收到请求之后和返回结果这件的这一段时间内的需要做的操作. 大大简化了开发人员的操作复杂度. 一个简单的 Web Application 会遵循一个简单的3层逻辑: PLD Presentation Tier: 如何展示给客户 Frontend HTML, CSS, Javascript, etc. Data Tier: 如何存储数据 SQL MongoDB, MySQL, etc. Logic Tier: 如何处理数据 Backend Java, Go, Python, etc. 简述 HTTP 请求: Request Line ( 请求类型( get, post, etc) , 访问的资源( host 地址的相对路径,访问之后触发的路径), HTTP/1.1(协议版本)) Request Header (额外信息, 支持语言, 浏览器类型等) Request Message Body (对内容进行更改) HTTP RESPONSE: Status Line ( 协议版本, 状态码 200, 404, 500, etc., 状态信息) Response Headers (Server 版本, 返回类型, etc) Response Message Body 对于 Message Body 通常使用 Json (Javascript Object Notation)格式, 比起 XML 更加简洁, 而却 key, value pair 的搜索效率更高.RPC (Remote Procedure Call): 对于 HTTP 请求进行处理然后返回相对应的结果这个过程.对于 Java 来说, Java Servlet 是专门用来处理客户端发到服务器端的请求的(rpc). 通常使用 HTTP 的请求类型是 Get 和 Post. 那么为什么偏向于用 Post 而不是用 Put 呢?因为 Put 是幂等( idempotent) 的操作, 而 Post 不是. 什么是幂等呢?对于一个操作和多个操作产生的结果是相同的, 这种操作叫做幂等. 而每一个操作产生的结果都不相同的操作成为非幂等操作.如果对某个文件进行一个更新操作, 我们希望保持结果的一致性.所以使用 Post. 简述 URL: protocal://hostname:port/endpoint?query通常 port 是不写的, 因为 每一个 protocal 有默认的端口号码. 除非我们希望监听特定的某个进程.endpoint 对应的是我们希望触发的的进程. 使用 REST 设计Web Service:使用 HTTP method 对应请求, 减少服务器端的操作, 直接通过HTTP request 判断用户需求.server 可以通过URL来判断请求对应的是哪一个文件/进程( service).请求和请求之间相互独立的, server 就不需要记录一个请求的状态以便于处理下一个请求(处于 stateless 状态).每个请求对应一个操作.提升数据处理量, 因为每一个请求都是相对独立的, 所以 server 不需要记录任何一个请求来处理下一个请求,因此 server 是无状态的, 所以当进行扩展的时候不需要考虑 server 的状态, 可以简单的使 server 运行在多个不同的机器上(平行扩展). 扩展性能高( scalibility). DataBase:ER (Entity Relationship) model: 只包含两种数据类型( Entity( 可以实例化), Entity 之间的关系(不能实例化))MySQL: Widely used open source relational database manaegement system. Table: 拥有相同属性的数据集合. 每一列对应一个属性. Row: 包含完整信息的一个 item. Column :属性. Schema: table 创建时候的结构(都有什么属性, 每一种属性有什么类型, 其他限制条件等). Consistency: 保持一致性, 但是慢. 数据耦合度高. NoSQL: Json-like distributed system using horizontal scaling. No schema. More flexible. Collection: 数据集合.不要求每一条数据拥有相同的属性. Document: 包含完整信息的一个 item. Field: 属性. (may vary from document to document) Avalibility: 及时同步, 速度快. 但是数据有可能不太一致.数据之间的耦合度低. CAP: Consistency: Every request will receive the most recent data. Availability: Every request will receive a response, which may not be up to the minute, without delay. Partition tolerance: Trade off consistency and availability for distributed system.]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web Application</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure V Tree III]]></title>
    <url>%2F2018%2F04%2F05%2FData%20Structure%20V%20Tree%20iii%2F</url>
    <content type="text"><![CDATA[─=≡Σ((( つ•̀ω•́)つ BS🌲 We often use recursion to solve the problem that involves tree(data structure). A binary tree has three parts, left subtree, root, and right subtree. This logic applies to every node in the tree including leaf nodes. If it has back track, it would be easier to just use recursion. However, if it is a tail trcursion, it can be converted into simple loops. Under this broad definition, however, every algorithm that uses recursion or loops could be regarded as a “divide and conquer algorithm”[1]. Search in Binary Search Treeinput: A root of a tree, and a target value.output: If exist, return the node; otherwise, return null. In a binary search tree, every node must satisfy the property that values in the left subtree must not be greater than it, and the value in the right subtree must not smaller than it. So we can recursively call the function. If the node value is smaller than target, look to its right. Otherwise, look to the left. Every time the function being called, the searching range is reduced to half. For a tree that has n nodes. The time complexity is O(logn). The space complexity is O(height) as well. However, the worst case could be O(n) if the tree is linear. Recursion 123456789101112public TreeNode searchBST(TreeNode root, int target) &#123; if (root == null) return null; if (root.val &lt; target) &#123; return searchBST(root.right, target); &#125; if(root.val &gt; target) &#123; return searchBST(root.left, target); &#125; return root.val == target ? root : null;&#125; IterationTime comlexity is the same. However, the space is O(1) in iteration. 123456789101112public TreeNode searchBST(TreeNode root, int target) &#123; if (root == null) return null; while (root != null &amp;&amp; root.val != target) &#123; if (root.val &lt; target) &#123; root = root.right; &#125; else &#123; root = root.left; &#125; &#125; return root;&#125; 如果所有的问题都这么简单, 世界该多么美好 ✧୧(๑=̴̀⌄=̴́๑)૭✧ ꒰ Insert in Binary Search Treeinput: A root and a target.output: Return the root after insertion (maintain its BST property). If the target exists in the tree, do nothing. There would be two steps: find the position for the node. Since it’s a binary search tree with no duplicate values, we can possibility find the postion under a leaf node. connect the node to the tree. Time compexity would be O(logn), where n is the number of node in the tree.Space compexity is the call stack, which is O(height). Recursion 123456789101112public TreeNode insert(TreeNode root, int target) &#123; if (root == null) return new TreeNode(target); if (root.val &lt; target) &#123; root.right = insert(root.right, target); &#125; if (root.val &gt; target) &#123; root.left = insert(root.left, target); &#125; return root;&#125; IterationTime complexity is O(logn).Space complexity is O(1). 123456789101112131415161718192021222324public TreeNode insert(TreeNode root, int target) &#123; if (root == null) return new TreeNode(target); TreeNode cur = root; TreeNode insetNode = new TreeNode(target); while (cur != null &amp;&amp; cur.val != target) &#123; if (cur.val &gt; target) &#123; if (cur.left == null) &#123; cur.left = insertNode; break; &#125; else &#123; cur = cur.left; &#125; &#125; else &#123; if (cur.right == null) &#123; cur.right = insertNode; break; &#125; else &#123; cur = cur.right; &#125; &#125; &#125; return root;&#125; Detele in Binary Search Treeinput: A root and the target.outpit: Return the root after deleting the target node in the tree (must maintain its BST property). If target doesn’t exist, simply return the root. There will be two steps: Find the node. Simply search in the tree. Adjust the structure after deletion. There will be 4 cases when deleting a node: The node is leaf node –&gt; simply delete The node only has left/right subtree –&gt; percolate up left/right subtree’s root. Since the subtree itself is a BST , it’s a subtree of the target node and it has no siblings (no need to compare with left/right subtree), it will maintain the property after lifting up. The node has both left and right subtree –&gt; pick a side, taking the largest node that is smaller than the node (look the left) or the smallest node that is greater than the node (look the right). Since we’re looking for the largest smaller one or the smallest larger one, there will be two situations that need to be considered. If the left subtree of the target doesn’t have a right subtree or the right subtree of the target doesn’t have a left subtree. Then the root of the subtree is the candidate. Due to the property of bst, all the left subtree is smaller than it and all the right subtree is greater than it for every node in the tree. If the left/right subtree of the target node has both left and right children, implement a helper function to find the left/right most node. For a tree with n nodes, time complexity for searching target takes O(logn), and adjustment can take O(height) for getting the left/right most node in the subtree. Therefore, the time complexity is O(2 * height), then is O(height). Space complexity is O(height) for stack frame if using recursion. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public TreeNode delete(TreeNode root, in target) &#123; if (root == null) return null; //Step1. find the node if (root.val &gt; target) &#123; root.left = delete(root.left, target); return root; &#125; else if (root.val &lt; target) &#123; root.right = delete(root.right, target); return root; &#125; //Step2. current root is target, adjustment //root != null &amp;&amp; root.val == target; //case11 &amp; 2 if (root.left == null) &#123; return root.right; &#125; else if (root.right == null) &#123; return root.left; &#125; //root.left != null &amp;&amp; root.right != null //case3.1 pick right if (root.right.left == null) &#123; root.right.left = root.left; return root.right; &#125; //case3.2 pick right, then find the smallest in the right subtree; TreeNode smallest = findSmallest(root.right); //reconnect the node, then return. smallest.left = root.left; smallest.right = root.right; return smallest;&#125;private TreeNode findSmallest(TreeNode node) &#123; TreeNode prev = node; node = node.left; while (node.left != null) &#123; prev = node; node = node.left; &#125; //node.left == null, current node is the left most. pre is current at the parent of node. pre.left = node.right; return node; &#125;&#125; [1]: “Divide and Conquer Algorithm.” Wikipedia, Wikimedia Foundation, 3 Apr. 2018, en.wikipedia.org/wiki/Divide_and_conquer_algorithm.]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure V Tree II]]></title>
    <url>%2F2018%2F04%2F04%2FData%20Structure%20V%20Tree%20ii%2F</url>
    <content type="text"><![CDATA[─=≡Σ((( つ•̀ω•́)つ Traverse 🌲 Pre-order Traverse Binary Tree (LeetCode 144. Binary Tree Preorder Traversal)input: The root of a tree.output: The list of elements of the tree in pre-order. The main concept of traversal is to visit each element once and only once. Therefore, the time comlexity should be O(n), where n is the number of node in the tree.Space complexity If using recursion, the space is stack frame, which is at most O(height). Iteration would require a extra data structure to simulate the call stack, and thus it’s O(height) as well. Recutsion 123456789101112131415161718192021public class traversePre &#123; /** * @param root * @return the preorder traversal of it's nodes' values; */ public List&lt;Integer&gt; traversePre(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return result; result.add(root.val); helper(root.left, result); helper(root.right, result); return result; &#125;&#125; Iteration 1234567891011121314151617181920212223242526public class traversePre &#123; /** * @param root * @return the preorder traversal of it's nodes' values; */ public List&lt;Integer&gt; traversePre(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;(); stack.offerFirst(root); //simulate the stack, so right first while (!stack.isEmpty()) &#123; TreeNode cur = stack.pollFirst(); result.add(cur.val); if (cur.right != null) stack.offerFirst(cur.right); if (cur.left != null) stack.offerFirst(cur.left); &#125; return result; &#125;&#125; In-order Traverse Binary Treeinput: The root of a tree.output: The list of elements of the tree in in-order. Same logic as pre-order. Therefore, time complexity is O(n), and space comlexity is O(height) for both recursion and iteration.Recursion 123456789101112131415161718192021public class TraverseIn &#123; /** * @param root of a binary tree * @return the inorder traversal of its nodes' values. */ public List&lt;Integer&gt; traverseIn(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return result; helper(root.left, result); result.add(root.val); helper(root.right, result); return result; &#125;&#125; IterationUsing A stack to simulate call stack. The process is push nodes along the left path. If reach the leaf node, pop the peek of the stack, which is the previous parent node of the leaf. If the peek node has a right child, push nodes along the left path of the child node as did before. Because of simulating the call stack, the space comlexity remains the same. T = O(n), S = O(height);123456789101112131415161718192021222324252627282930313233public class TraverseIn &#123; /** * @param root of a binary tree * @return the inorder traversal of its nodes' values. */ public List&lt;Integer&gt; traverseIn(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); pushLeft(root, stack); while (!stack.isEmpty()) &#123; TreeNode cur = stack.pollFirst(); result.add(cur.val); cur = cur.right; pushLeft(cur, stack); &#125; return result; &#125; private void pushLeft(TreeNode root, Deque&lt;TreeNode&gt; stack) &#123; while (root != null) &#123; stack.offerFirst(root); root = root.left; &#125; &#125;&#125; Post-order Traverse Binary Treeinput: The root of a tree.output: The list of elements of the tree in post-order. Same logic as pre-order. Therefore, time complexity is O(n), and space comlexity is O(height) for both recursion and iteration. Recursion 12345678910111213141516171819202122public class TraversePost &#123; /** * @param root of a binary tree * @return the postOrder traversal of its nodes' values. */ public List&lt;Integer&gt; traversePost(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return result; helper(root.left, result); helper(root.right,result); result.add(root.val); return result; &#125;&#125; IterationOnly pop the stack if right child is visited or it is the leaf node. There are two stages in the traversal, Tacking downward if current node is the root, push to the stack. if current node has child, push to the stack. if current node is the leaf node, update the result, pop from the stack. Backtracking if previous visited node is the left child, look at its right. if right child is not empty, push to the stack. if right child is empty, add current node into the result, and pop it from the stack. if previous visited node is the right child, this subtree is finished, pop the stack. There is a logic overlap. Whether the right is visited or the node doesn’t have a right subtree, current node can be popped. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class TraversePost &#123; /** * @param root of a binary tree * @return the postOrder traversal of its nodes' values. */ public List&lt;Integer&gt; traversePost(TreeNode root) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if (root == null) return result; return helper(root, result); &#125; private List&lt;Integer&gt; helper(TreeNode root, List&lt;Integer&gt; result) &#123; Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;(); stack.offer(root); TreeNode prev = null; TreeNode cur = root; while (!stack.isEmpty()) &#123; cur = stack.peekFirst(); //cur is root, cur is leafnode if (prev == null || cur == prev.left || cur == prev.right) &#123; if (cur.left != null) &#123; stack.offerFirst(cur.left); &#125; else if (cur.right != null) &#123; stack.offerFirst(cur.right); //the peek of the stack (last added) is leaf &#125; else &#123; result.add(cur.val); stack.pollFirst(); &#125; //left child is visited &#125; else if (prev == cur.left) &#123; //if it has right child if (cur.right != null) &#123; stack.offerFirst(cur.right); &#125; /*else &#123; result.add(cur.val); stack.pollFirst(); &#125;*/ //if right child is visited. &#125; else &#123; result.add(cur.val); stack.pollFirst(); &#125; prev = cur; &#125; return result; &#125;&#125; Level Order Traverse Binary Treeinput: The root of a tree.output: The list of elements of the tree in level-order. The concept of traversal is as same as pre-order. However, the extra data structure being used here is a queue, which is FIFO, beacuse it goes from top to bottom and left to right.The time comlexity is O(n) as other traversal orders, but the space would be the level that has the most nodes in the tree. Then the worst case would be the leaf level in a perfect tree (every node has 2 children), so it’s O(2/n - 1) –&gt; O(n). 123456789101112131415161718192021public class LevelOrder &#123; /** * @param root * @return */ public List&lt;Integer&gt; traverseLevel(TreeNode root) &#123; if (root == null) return new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.offer(root); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); while (!q.isEmpty()) &#123; TreeNode cur = q.poll(); result.add(cur.val); if (cur.left != null) q.offer(cur.left); if (cur.right != null) q.offer(cur.right); &#125; return result; &#125;&#125; Identical Tree (LeetCode 100 Same Tree)input: roots of two binary trees.output: return whether they are structually identical and the nodes have the same number. Picking a traversal order and compare nodes value while traversing. Time complexity is O(n) where n is the number of nodes. Space complexity is O(height) if using preorder, inorder or postorder. O(n) is using level order.123456789101112131415161718192021public class SameTree &#123; /** * @param p root of a binary tree; * @param q root of a binary tree * @return whether they are the same */ public boolean isSameTree(TreeNode p, TreeNode q) &#123; if (p == null &amp;&amp; q == null) &#123; return true; &#125; if (p == null || q == null) &#123; return false; &#125; if (p.val != q.val) &#123; return false; &#125; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); &#125;&#125; Minimum Depth of Binary Tree (LeetCode 111)input: root of a bianry tree.output: the min depth of the tree. There are 2 cases: If the root doesn’t have left subtree or left subtree, min depth is the depth. If the root has a left subtree and a right subtree, return the min depht of its subtree plus 1 for current level of the root. Since only visit each node once, time complexity is O(n). Space complexity is O(height). 1234567891011121314151617181920public class MinDepth &#123; /** * @param root * @return min depth */ public int minDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; if (root.left == null) &#123; return minDepth(root.right) + 1; &#125; if (root.right == null) &#123; return minDepth(root.left) + 1; &#125; return Math.min(minDepth(root.left), minDepth(root.right)) + 1; &#125;&#125; Balanced Binary Tree (LeetCode 110)input: root of a binary tree;output: whether the tree is balanced. A binary tree in which the depth of the two subtrees of every node never differ by more than 1.1 Since it deals with the height of a tree, the main concept is to get the height of each subtree. The difference of height needs to be checked for every node in the tree according to the definition of a balanced binary tree. Therefore, it is easier to use recursion. They way to get the height of a tree is returning the maximum of left and right subtree and plus 1 for the level of root.At each level, root checks whether it’s left and right subtree are balanced, if so, return the height. Otherwise, return a special value shown that there exists an unbalanced subtree. Since it takes the same time as getting the height of a tree, the time comlexity is O(n). The space complexity is O(height). 123456789101112131415161718192021222324public class isBalanced &#123; /** * @param root of a binary tree * @return if it is height-balanced */ public boolean isBalanced(TreeNode root) &#123; if (root == null) &#123; return true; &#125; return getHeight(root) != -1; &#125; private int getHeight(TreeNode root) &#123; if (root == null) return 0; int left = getHeight(root.left); int right = getHeight(root.right); if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) &#123; return -1; &#125; return Math.max(left, right) + 1; &#125;&#125; Flatten Binary Tree to LinkedListinput: root of a binary tree;output: void 1 / \ 2 5 / \ \3 4 6 =&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 Assume all nodes are already connected, at each level, the root needs to do two things. Connect previous nodes to it’s right, and disconnect it’s left child. For example, if focusing on the subtree 2 -&gt; 3 -&gt; 4, at the point the root is 2, node 3 and node 4 are already connected, because it’s postorder traversal. Using a class field to save previous connected node.Using postorder traversal, the most right leaf node is the tail node of the linked list. Time comlexity is O(n) where n is the number of nodes in the tree. Space complexity is O(height) due to the use of call stack. 123456789101112131415public class FlattenTreeToList &#123; /** * @param root of a binary tree */ private TreeNode prev = null; public void flatten(TreeNode root) &#123; if (root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; &#125;&#125; Lowest Common Ancestor (LCA) Iinput: root of a binary tree, and two target nodes. Target Nodes are guaranteed to be in the tree.output: find the lowest comment ancestor of two target nodes. The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself)2. Using post order traverse, return target exist in the subtree otherwise return nothing. Time complexity is O(n) where n is the number of nodes in the tree. Space complexity is O(height) for call stack. The process is shown in the picture. 12345678910111213141516171819202122public class LCAI &#123; /** * @param root * @param a * @param b * @return */ public TreeNode lca(TreeNode root, TreeNode a, TreeNode b) &#123; if (root == null || root == a || root == b) &#123; return root; &#125; TreeNode left = lca(root.left, a, b); TreeNode right = lca(root.right, a, b); if (left == null) return right; if (right == null) return left; //left != null &amp;&amp; right != null return root; &#125;&#125; Count Univalue Subtrees (LeetCode 250)input: root node of a binary tree.output: return number of subtrees that have same value. Beacuse of looking for subtree, it is better to use post order traverse. Here uses return value to determine whether the root can form a valid subtree. If so, the root adds to the result. Otherwise, result number remains the same. There are two things to do at each level. comparing the nodes of left and right subtree to the root. updating the number of univalue subtree.IFF both left and right subtree are valid subtree and the valud of nodes of both left and right subtrees (if exist) and the value of root are the same, number of subtree can be updated. Since whether root can be counted as a univalue subtree is rely one the value of its subtree, there should be passing a boolean value. At the meantime, count needs to be updated (or not). 私はここでエラーをした。サブツリーの数を間違って直接渡す. でも、この方法は、こんなの状況に対処する方法はありません。Since it’s using post order traverse, every node will be visited once. The time complexity is O(n). Space compelxity is O(height) for call stack. 1234567891011121314151617181920212223242526272829303132333435public class UniValueSubtree &#123; /** * @param root * @return */ public int countUnivalSubtrees(TreeNode root) &#123; if (root == null) return 0; int[] count = &#123;0&#125;; helper(root, count); return count[0]; &#125; private boolean helper(TreeNode root, int[] count) &#123; if (root == null) return true; boolean left = helper(root.left, count); boolean right = helper(root.right, count); //if (root.left == null &amp;&amp; root.right == null) count[0]++; //root == null returns true guarantees leaf node count++; if (left &amp;&amp; right) &#123; if (root.left != null &amp;&amp; root.left.val != root.val) &#123; return false; &#125; if (root.right != null &amp;&amp; root.right.val != root.val) &#123; return false; &#125; count[0]++; return true; &#125; ///////had made a mistake here, keep in mind.... return false; &#125;&#125; Check Full Binary Treeinput: root of a binary tree.output: return whether its a full tree. A binary tree in which all nodes have either zero or two child nodes. Using post order traversal, if any of the tree node has single child, return false. Time complexity is O(n). Space complexity is O(height) for call stack.1234567891011121314151617public class CheckFullTree &#123; /** * @param root: the given tree * @return: Whether it is a full tree */ public boolean isFullTree(TreeNode root) &#123; if (root == null) return true; if (root.left == null &amp;&amp; root.right == null) &#123; return true; &#125; if (root.left == null || root.right == null) &#123; return false; &#125; return isFullTree(root.left) &amp;&amp; isFullTree(root.right); &#125;&#125; Maximum Path Sum Iinput: a root of a binary tree.output: maximum value from one leaf node to another leaf node. Using a reference to keep global max. While traversing, if a root has both left and right subtree, it is a candidate to update global max value. Otherwise, return the maximum value of left and right plus the root’s value. The time complexity is O(n) becuase only visit every node once. The space complexity is O(height) due to the call stack. 123456789101112131415161718192021222324252627public class MaxPathSumI &#123; /** * @param root * @return */ public int maxPathSum(TreeNode root) &#123; int[] max = &#123;Integer.MIN_VALUE&#125;; helper(root, max); return max[0]; &#125; private int helper(TreeNode root, int[] max) &#123; if (root == null) &#123; return 0; &#125; int left = helper(root.left, max); int right = helper(root.right, max); if (root.left != null &amp;&amp; root.right != null) &#123; max[0] = Math.max(max[0], left + right + root.val); return Math.max(left, right) + root.val; &#125; //if not return, left == null || right == null return root.left == null ? right + root.val : left + root.val; &#125;&#125; Maximum Path Sum IIinput: a root of a binary tree.output: maximum value from any node to any node (contains at least one node). The only difference between this problem and previous one is the condition of updating global max. If the sum returned from subtree is positive, keep it and compare. Otherwise, set it to 0. The time complexity is O(n) beacuse it only visits every node once. The space complexity is O(height) due to the call stack. public class MaxPathSumII { /** * @param root * @return */ public int maxPathSum(TreeNode root) { int[] max = {Integer.MIN_VALUE}; helper(root, max); return max[0]; } private int helper(TreeNode root, int[] max) { if (root == null) return 0; int left = helper(root.left, max); int right =helper(root.right, max); left = left &lt; 0 ? 0 : left; right = right &lt; 0 ? 0 : right; max[0] = Math.max(max[0], left + right + root.val); return Math.max(left, right) + root.val; } } ### 1.https://leetcode.com/problems/balanced-binary-tree/description/ ↩2.https://en.wikipedia.org/wiki/Lowest_common_ancestor ↩]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure V Tree I]]></title>
    <url>%2F2018%2F04%2F03%2FData%20Structure%20V%20Tree%2F</url>
    <content type="text"><![CDATA[A directed acyclic graph (DAG!) is a directed graph that contains no cycles. A rooted tree is a special kind of DAG and a DAG is a special kind of directed graph. For example, a DAG may be used to represent common subexpressions in an optimising compiler.[1] 树的性质对于线性数据结构来说, 元素与元素之间的关系是一对一的. 例如, 在 Linked list 中, 每一个元素只有一个 preceding 和一个 following element. 而对于一对多的情况, 就需要另外一种数据结构树(tree)/图(graph)来处理了. 树是一个特殊的图(DAG). 对于一个非空的树来说, 它是一个拥有 n 个节点(n &gt;= 0) 的有限集合. 这个集合有且只有一个根节点(root), 其他节点可以被看做若干个不相交的子集(n - 1). 而这 n - 1个子集被视为 root 的子树(subtree). 通过 root 可以访问到它所有的子树[2]. depth: 从节点到 root 的高度.height: 从 root 到离它最远的节点的距离.degree: 节点拥有的子树的最大数量. 对于一个 tree 中的每一个节点来说, 它的 parent 节点是确定的, 但是 child 节点可以有多个. 对于多个子节点的表示则可以使用 List 这种形式来表示. 对于每一个节点来说, 它有多少个子树, 就要有多少个 reference 指向这些子树. 那么同样的, 遍历每一个子树的时间复杂度就是子树节点的个数. 所以对于一个没有 parent reference 的tree, 因为只能够通过 root 来遍历/搜索元素, 时间复杂度为 O(n). 如果有必要的情况下, 可以增加一个 parent 的域. 在遇到复杂的树状结构的时候, 可以使用 child refernce 和sibling reference 来指向当前节点的子节点和兄弟节点. 这样就可以转化成一个简单的二叉树的结构了. 二叉树下面来说下特殊的树, 二叉树(binary tree). 二叉树具有五种基本形态, 空树, 只有一个根节点, 根节点只有左子树, 根节点只有右子树, 根节点拥有左右子树. 这个状态适用于每一个节点. 所以对于一个有3个节点的树来说, 它应该具有如下几种形态, 有一些形态具有特殊的性质, 这些性质可以帮助我们高效的处理一些数据. 例如, 满二叉树(full binary tree): 每一个节点只有两个状态, 没有子树, 或者有两个子树. 完美二叉树(perfect binary tree): 除叶子节点外的 node 都拥有2个子树, 并且所有的叶子节点都在同一层. 上图中的第一个. 完全二叉树(complete binary tree): 任意节点子树之间高度差不超过1, 也就是说叶子节点只能出现在最下面两层, 如果叶子节点不在同一层, 那么最下一层的叶子节点一定在左边连续位置. 同样的, 如果是倒数第二层的叶子节点, 那么一定在最右边连续位置(其实记住 bubble 在左就够了). 如果一个节点只有一个子树, 那么这个子树一定在左边. 同样节点数的二叉树, 完全二叉树的深度最小. 对于一个拥有 n 个节点的完全二叉树来说, 它的深度是 logn + 1. 若按照层序从1 ~ n排列, 对于每一个元素 i(1 &lt;= i &lt;= n), 如果 i == 1, 那么 i 是 root, 如果 i &gt; 1, 它的 parent node 是 i / 2, 如果 2i &gt; n, 则 i 没有左子树( i 为叶子节点). 如果 2i == n, 则 2i 是 i 的左子树. 如果2i + 1 &gt; n, 则 i 没有右子树. 如果2i + 1 == n, 那么2i 是 i 的右子树. 平衡二叉树(balanced binary tree): 任意节点子树之间高度差不超过1. 二叉搜索树(binary search tree): 对于任意节点来说, 它所有左子树不能大于它, 所有右子树不能小于它. 中序遍历结果一定是升序. perfect tree一定是完全二叉树, 完全二叉树一定是平衡二叉树.这里 full tree 和 perfect tree 的定义还是有一些争议…. 二叉树的遍历二叉树的遍历( traversing binary tree)是指从 root 出发, 按照某种顺序访问所有节点. 每个节点只被访问一次.对于一个二叉树来说, 遍历的顺序可以分为深度优先和宽度优先. 根据根节点所在的位置的不同, 深度优先又可以被分为前序, 中序和后序遍历. pre-order traverse: 对于每一个节点来说, 先访问它自己, 再访问左子树, 然后访问右子树. 上图结果应该是, 18 --&gt; 4 --&gt; 2 --&gt; 1 --&gt; 3 --&gt; 6 --&gt; 5 --&gt; 7 --&gt; 12 --&gt; 10 --&gt; 9 --&gt; 11 --&gt; 14 --&gt; 13 --&gt; 15 in-order traverse: 对于每一个节点来说, 先访问左子树, 在访问它自己, 然后访问右子树( root 在中间). 上图结果应该是, 11 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6 --&gt; 7 --&gt; 8 --&gt; 9 --&gt; 10 --&gt; 11 --&gt; 12 --&gt; 13 --&gt; 14 --&gt; 15 post-order traverse: 同理, 先左子树, 然后右子树, 最后访问它自己. 上图访问结果, 115 --&gt; 13 --&gt; 14 --&gt; 11 --&gt; 9 --&gt; 10 --&gt; 12 --&gt; 7 --&gt; 5 --&gt; 6 --&gt; 3 --&gt; 1 --&gt; 2 --&gt; 4 --&gt; 8 level oder traverse: 从上到下, 从左到右分层访问, 通常会用一个 queue 来储存每一层的 TreeNode, 18 --&gt; 4 --&gt; 12 --&gt; 2 --&gt; 6 --&gt; 10 --&gt; 14 --&gt; 1 --&gt; 3 --&gt; 5 --&gt; 7 --&gt; 9 --&gt; 11 --&gt; 13 --&gt; 15 已知前序遍历/后序遍历和中序遍历可以确定唯一一个二叉树, 而知道前序遍历和后续遍历则无法还原一个二叉树的. 这是因为通过前序/后续遍历可以轻而易举的确定 root, 而中序遍历则可以通过这个 root 来确定左右子树的范围. 举例说明上面结果中前序遍历和中序遍历如何还原一个二叉树. 已经pre-order 中, 8是唯一确定的 root, 那么in-order 中, 1 ~ 7则一定是左子树, 9 ~ 12 一定是右子树. 如下,继续通过pre-oder 的顺序获取左子树root,直到最后左右子树元素为1, 那么确定为叶子节点. 最后再通过同样的逻辑还原右子树. 把二叉树以某种顺序线索化(双链表或者 arraylist)的过程叫做序列化, 反之则是反序列化. [1]: “Directed Acyclic Graphs.” Directed Acyclic Graph (DAG) Algorithms, www.allisons.org/ll/AlgDS/Graph/DAG/.[2]: 《大话数据结构》 程杰. www.bing.com/cr?IG=31B9721229184349AAEC19BE676BAC6F&amp;CID=362C81AF801A620D0EAF8A7881B563E4&amp;rd=1&amp;h=OJ2Sq1D4wfXY6mddIv_zw1DEo8UFjkz32ZCngLj1biE&amp;v=1&amp;r=https://www.amazon.cn/dp/B0053F0HNW&amp;p=DevEx.LB.1,5871.1.]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linear Data Structure iii Stack]]></title>
    <url>%2F2018%2F04%2F03%2FLinear%20Data%20Structure%20iii%2F</url>
    <content type="text"><![CDATA[线性数据结构(三) 栈Stack 是一种后进先出的数据结构(FILO), 基本的操作有 push(), pop(), peek(), size() 和 isEmpty(). 因为它只能从一边进出, 所以是倒序的操作.所以可能想到的应用场景应该是各种对于顺序的操作. 以及相邻两个元素进行对比. 虽然它的操作很简单, 但是根据进栈和出栈的顺序不同, 可以得出不同的结果. 12345678910栈内元素: 1, 2, 3出栈的顺序可能有: 3, 2, 1; 1, 2, 3; 2, 3, 1; 2, 1, 3; 1, 3, 2;唯一不可能是情况是312, 因为如果3 已经进栈了, 那么就意味着 1 和 2 已经进(过)栈了. 而1 比 2 先进栈, 不可能比2先出栈. A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example: Deque stack = new ArrayDeque(); Java 中 stack 的实现通常会使用 Deque 这个 interface, 而不再使用 Stack 这个类了. 具体原因: 对于最新的 Java framework 来说, Stack 的线程安全显得太冗余. 通过 LinkedList 和 ArrayList 实现的 Deque 可以实现 Deque 和 Stack 的各种增删改查功能. 这样使得数据结构的整合更加统一, 使用 generic 类型来创建对象也更符合 Java OOP 的设计理念. 最后 LinkedList 和 ArrayList 都不是 Synchronized, 所以开销更小. 使用 Deque 接口: operation FistElement Last Element return type exception null Exception null insert addFirst offerFirst addLast offerLast remove removeFirst pollFirst removeLast removeFirst examine getFirst peekFirst getLast peekLast 代码实现: 使用LinkedList 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyStackLL&lt;E&gt; &#123; private static class ListNode&lt;E&gt; &#123; public E val; public ListNode next; public ListNode(E val) &#123; this.val = val; this.next = null; &#125; &#125; private ListNode head; private int size; public MyStackLL()&#123; head = null; &#125; public void push(E e)&#123; ListNode&lt;E&gt; node = new ListNode(e); node.next = head; head = node; size++; &#125; public E pop()&#123; if (head == null) &#123; return null; &#125; ListNode&lt;E&gt; node = head; head = head.next; node.next = null; size--; return node.val; &#125; public Object peek() &#123; if (head == null) &#123; return null; &#125; else &#123; return head.val; &#125; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; 使用Array 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyStackAL&lt;E&gt; &#123; private Object[] array; private static final int CAP = 16; private static final int SCALE_FACTOR = 2; int top; int size; public MyStackAL() &#123; array = new Object[CAP]; top = -1; &#125; public void push(E e) &#123; if (top == array.length - 1) &#123; array = Arrays.copyOf(array, CAP * SCALE_FACTOR); &#125; array[++top] = e; size++; &#125; public Object pop() &#123; if (top &lt; 0) &#123; return null; &#125; Object res = array[top--]; size--; return res; &#125; public Object peek() &#123; return top &lt; 0 ? null : array[top]; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; 所有操作的时间复杂度均为 O(1), 使用 array 的扩容方法 amortize 的时间复杂度依然是 O(1). because the initial capacity is n. At the time we need to extend the capacity of the stack, it takes O(n) to copy the elements, and push operation will take O(1) for the upcoming n elements. When we add up the time of copy and adding, the average time complexity for each of upcoming elements will be O(n) + O(n) / n = O(2). Thus the amortized time complexity is O(1).]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>review plan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure]]></title>
    <url>%2F2018%2F04%2F01%2FData-Structure%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>review plan</tag>
      </tags>
  </entry>
</search>
